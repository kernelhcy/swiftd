The C10K problem

It's time for web servers to handle ten thousand clients simultaneously, don't you think? After all, the web is a big place now.

And computers are big, too. You can buy a 1000MHz machine with 2 gigabytes of RAM and an 1000Mbit/sec Ethernet card for $1200 or so. Let's see - at 20000 clients, that's 50KHz, 100Kbytes, and 50Kbits/sec per client. It shouldn't take any more horsepower than that to take four kilobytes from the disk and send them to the network once a second for each of twenty thousand clients. (That works out to $0.08 per client, by the way. Those $100/client licensing fees some operating systems charge are starting to look a little heavy!) So hardware is no longer the bottleneck.

In 1999 one of the busiest ftp sites, cdrom.com, actually handled 10000 clients simultaneously through a Gigabit Ethernet pipe. As of 2001, that same speed is now being offered by several ISPs, who expect it to become increasingly popular with large business customers.

And the thin client model of computing appears to be coming back in style -- this time with the server out on the Internet, serving thousands of clients.

With that in mind, here are a few notes on how to configure operating systems and write code to support thousands of clients. The discussion centers around Unix-like operating systems, as that's my personal area of interest, but Windows is also covered a bit.

1 Related Sites

In October 2003, Felix von Leitner put together an excellent web page and presentation about network scalability, complete with benchmarks comparing various networking system calls and operating systems. One of his observations is that the 2.6 Linux kernel really does beat the 2.4 kernel, but there are many, many good graphs that will give the OS developers food for thought for some time. (See also the Slashdot comments; it'll be interesting to see whether anyone does followup benchmarks improving on Felix's results.)

2 Book to Read First

If you haven't read it already, go out and get a copy of Unix Network Programming : Networking Apis: Sockets and Xti (Volume 1) by the late W. Richard Stevens. It describes many of the I/O strategies and pitfalls related to writing high-performance servers. It even talks about the 'thundering herd' problem. And while you're at it, go read Jeff Darcy's notes on high-performance server design.

(Another book which might be more helpful for those who are *using* rather than *writing* a web server is Building Scalable Web Sites by Cal Henderson.)

3 I/O frameworks

Prepackaged libraries are available that abstract some of the techniques presented below, insulating your code from the operating system and making it more portable.

	（1）ACE, a heavyweight C++ I/O framework, contains object-oriented implementations of some of these I/O 		
	strategies and many other useful things. In particular, his Reactor is an OO way of doing nonblocking I/O, and 
	Proactor is an OO way of doing asynchronous I/O.
	（2）ASIO is an C++ I/O framework which is becoming part of the Boost library. It's like ACE updated for the STL 
	era.
	（3）libevent is a lightweight C I/O framework by Niels Provos. It supports kqueue and select, and soon will 
	support poll and epoll. It's level-triggered only, I think, which has both good and bad sides. Niels has a nice 
	graph of time to handle one event as a function of the number of connections. It shows kqueue and sys_epoll as 
	clear winners.
	（4）My own attempts at lightweight frameworks (sadly, not kept up to date):
		（a）Poller is a lightweight C++ I/O framework that implements a level-triggered readiness API using 
		whatever underlying readiness API you want (poll, select, /dev/poll, kqueue, or sigio). It's useful for 
		benchmarks that compare the performance of the various APIs. This document links to Poller subclasses below 
		to illustrate how each of the readiness APIs can be used.
		（b）rn is a lightweight C I/O framework that was my second try after Poller. It's lgpl (so it's easier to 
		use in commercial apps) and C (so it's easier to use in non-C++ apps). It was used in some commercial 
		products.
	（5）Matt Welsh wrote a paper in April 2000 about how to balance the use of worker thread and event-driven 
	techniques when building scalable servers. The paper describes part of his Sandstorm I/O framework.
	（6）Cory Nelson's Scale! library - an async socket, file, and pipe I/O library for Windows

4 I/O Strategies

Designers of networking software have many options. Here are a few:
	(1) Whether and how to issue multiple I/O calls from a single thread
		(a) Don't; use blocking/synchronous calls throughout, and possibly use multiple threads or processes to 
		    achieve concurrency
		(b) Use nonblocking calls (e.g. write() on a socket set to O_NONBLOCK) to start I/O, and readiness 
		    notification (e.g. poll() or /dev/poll) to know when it's OK to start the next I/O on that channel. 
		    Generally only usable with network I/O, not disk I/O.
		(c) Use asynchronous calls (e.g. aio_write()) to start I/O, and completion notification (e.g. signals or 
			completion ports) to know when the I/O finishes. Good for both network and disk I/O.
	(2) How to control the code servicing each client
		(a) one process for each client (classic Unix approach, used since 1980 or so)
		(b) one OS-level thread handles many clients; each client is controlled by:
			@ a user-level thread (e.g. GNU state threads, classic Java with green threads)
			@ a state machine (a bit esoteric, but popular in some circles; my favorite)
			@ a continuation (a bit esoteric, but popular in some circles)
		(c) one OS-level thread for each client (e.g. classic Java with native threads)
		(d) one OS-level thread for each active client (e.g. Tomcat with apache front end; NT completion ports; 
			thread pools)
	(3) Whether to use standard O/S services, or put some code into the kernel (e.g. in a custom driver, kernel 
		module, or VxD)

The following five combinations seem to be popular:

	Serve many clients with each thread, and use nonblocking I/O and level-triggered readiness notification
	Serve many clients with each thread, and use nonblocking I/O and readiness change notification
	Serve many clients with each server thread, and use asynchronous I/O
	serve one client with each server thread, and use blocking I/O
	Build the server code into the kernel

4.1. Serve many clients with each thread, and use nonblocking I/O and level-triggered readiness notification

... set nonblocking mode on all network handles, and use select() or poll() to tell which network handle has data waiting. This is the traditional favorite. With this scheme, the kernel tells you whether a file descriptor is ready, whether or not you've done anything with that file descriptor since the last time the kernel told you about it. (The name 'level triggered' comes from computer hardware design; it's the opposite of 'edge triggered'. Jonathon Lemon introduced the terms in his BSDCON 2000 paper on kqueue().)

Note: it's particularly important to remember that readiness notification from the kernel is only a hint; the file descriptor might not be ready anymore when you try to read from it. That's why it's important to use nonblocking mode when using readiness notification.

An important bottleneck in this method is that read() or sendfile() from disk blocks if the page is not in core at the moment; setting nonblocking mode on a disk file handle has no effect. Same thing goes for memory-mapped disk files. The first time a server needs disk I/O, its process blocks, all clients must wait, and that raw nonthreaded performance goes to waste. 
This is what asynchronous I/O is for, but on systems that lack AIO, worker threads or processes that do the disk I/O can also get around this bottleneck. One approach is to use memory-mapped files, and if mincore() indicates I/O is needed, ask a worker to do the I/O, and continue handling network traffic. Jef Poskanzer mentions that Pai, Druschel, and Zwaenepoel's 1999 Flash web server uses this trick; they gave a talk at Usenix '99 on it. It looks like mincore() is available in BSD-derived Unixes like FreeBSD and Solaris, but is not part of the Single Unix Specification. It's available as part of Linux as of kernel 2.3.51, thanks to Chuck Lever.

But in November 2003 on the freebsd-hackers list, Vivek Pei et al reported very good results using system-wide profiling of their Flash web server to attack bottlenecks. One bottleneck they found was mincore (guess that wasn't such a good idea after all) Another was the fact that sendfile blocks on disk access; they improved performance by introducing a modified sendfile() that return something like EWOULDBLOCK when the disk page it's fetching is not yet in core. (Not sure how you tell the user the page is now resident... seems to me what's really needed here is aio_sendfile().) The end result of their optimizations is a SpecWeb99 score of about 800 on a 1GHZ/1GB FreeBSD box, which is better than anything on file at spec.org.

There are several ways for a single thread to tell which of a set of nonblocking sockets are ready for I/O:

	(a) The traditional select() 
	Unfortunately, select() is limited to FD_SETSIZE handles. This limit is compiled in to the standard library and 
	user programs. (Some versions of the C library let you raise this limit at user app compile time.)
	See Poller_select (cc, h) for an example of how to use select() interchangeably with other readiness 
	notification schemes.

	(b) The traditional poll() 
	There is no hardcoded limit to the number of file descriptors poll() can handle, but it does get slow about a 
	few thousand, since most of the file descriptors are idle at any one time, and scanning through thousands of 
	file descriptors takes time.
	Some OS's (e.g. Solaris 8) speed up poll() et al by use of techniques like poll hinting, which was implemented 
	and benchmarked by Niels Provos for Linux in 1999.

	See Poller_poll (cc, h, benchmarks) for an example of how to use poll() interchangeably with other readiness 
	notification schemes.

	(c)/dev/poll
	This is the recommended poll replacement for Solaris.
	The idea behind /dev/poll is to take advantage of the fact that often poll() is called many times with the same 
	arguments. With /dev/poll, you get an open handle to /dev/poll, and tell the OS just once what files you're 
	interested in by writing to that handle; from then on, you just read the set of currently ready file
	 descriptors from that handle.

	It appeared quietly in Solaris 7 (see patchid 106541) but its first public appearance was in Solaris 8; 	
	according to Sun, at 750 clients, this has 10% of the overhead of poll().

	Various implementations of /dev/poll were tried on Linux, but none of them perform as well as epoll, and were 
	never really completed. /dev/poll use on Linux is not recommended.

	See Poller_devpoll (cc, h benchmarks ) for an example of how to use /dev/poll interchangeably with many other 
	readiness notification schemes. (Caution - the example is for Linux /dev/poll, might not work right on Solaris.)

	(d)kqueue()
	This is the recommended poll replacement for FreeBSD (and, soon, NetBSD).
	See below. kqueue() can specify either edge triggering or level triggering.

4.2. Serve many clients with each thread, and use nonblocking I/O and readiness change notification

Readiness change notification (or edge-triggered readiness notification) means you give the kernel a file descriptor, and later, when that descriptor transitions from not ready to ready, the kernel notifies you somehow. It then assumes you know the file descriptor is ready, and will not send any more readiness notifications of that type for that file descriptor until you do something that causes the file descriptor to no longer be ready (e.g. until you receive the EWOULDBLOCK error on a send, recv, or accept call, or a send or recv transfers less than the requested number of bytes).
When you use readiness change notification, you must be prepared for spurious events, since one common implementation is to signal readiness whenever any packets are received, regardless of whether the file descriptor was already ready.

This is the opposite of "level-triggered" readiness notification. It's a bit less forgiving of programming mistakes, since if you miss just one event, the connection that event was for gets stuck forever. Nevertheless, I have found that edge-triggered readiness notification made programming nonblocking clients with OpenSSL easier, so it's worth trying.

[Banga, Mogul, Drusha '99] described this kind of scheme in 1999.

There are several APIs which let the application retrieve 'file descriptor became ready' notifications:

kqueue() This is the recommended edge-triggered poll replacement for FreeBSD (and, soon, NetBSD).
FreeBSD 4.3 and later, and NetBSD-current as of Oct 2002, support a generalized alternative to poll() called kqueue()/kevent(); it supports both edge-triggering and level-triggering. (See also Jonathan Lemon's page and his BSDCon 2000 paper on kqueue().)

Like /dev/poll, you allocate a listening object, but rather than opening the file /dev/poll, you call kqueue() to allocate one. To change the events you are listening for, or to get the list of current events, you call kevent() on the descriptor returned by kqueue(). It can listen not just for socket readiness, but also for plain file readiness, signals, and even for I/O completion.

Note: as of October 2000, the threading library on FreeBSD does not interact well with kqueue(); evidently, when kqueue() blocks, the entire process blocks, not just the calling thread.

See Poller_kqueue (cc, h, benchmarks) for an example of how to use kqueue() interchangeably with many other readiness notification schemes.

Examples and libraries using kqueue():

PyKQueue -- a Python binding for kqueue()
Ronald F. Guilmette's example echo server; see also his 28 Sept 2000 post on freebsd.questions.
epoll
This is the recommended edge-triggered poll replacement for the 2.6 Linux kernel.
On 11 July 2001, Davide Libenzi proposed an alternative to realtime signals; his patch provides what he now calls /dev/epoll www.xmailserver.org/linux-patches/nio-improve.html. This is just like the realtime signal readiness notification, but it coalesces redundant events, and has a more efficient scheme for bulk event retrieval.

Epoll was merged into the 2.5 kernel tree as of 2.5.46 after its interface was changed from a special file in /dev to a system call, sys_epoll. A patch for the older version of epoll is available for the 2.4 kernel.

There was a lengthy debate about unifying epoll, aio, and other event sources on the linux-kernel mailing list around Halloween 2002. It may yet happen, but Davide is concentrating on firming up epoll in general first.

Polyakov's kevent (Linux 2.6+) News flash: On 9 Feb 2006, and again on 9 July 2006, Evgeniy Polyakov posted patches which seem to unify epoll and aio; his goal is to support network AIO. See:
the LWN article about kevent
his July announcement
his kevent page
his naio page
some recent discussion
Drepper's New Network Interface (proposal for Linux 2.6+)
At OLS 2006, Ulrich Drepper proposed a new high-speed asynchronous networking API. See:
his paper, "The Need for Asynchronous, Zero-Copy Network I/O"
his slides
LWN article from July 22
Realtime Signals
This is the recommended edge-triggered poll replacement for the 2.4 Linux kernel.
The 2.4 linux kernel can deliver socket readiness events via a particular realtime signal. Here's how to turn this behavior on:

/* Mask off SIGIO and the signal you want to use. */
sigemptyset(&sigset);
sigaddset(&sigset, signum);
sigaddset(&sigset, SIGIO);
sigprocmask(SIG_BLOCK, &m_sigset, NULL);
/* For each file descriptor, invoke F_SETOWN, F_SETSIG, and set O_ASYNC. */
fcntl(fd, F_SETOWN, (int) getpid());
fcntl(fd, F_SETSIG, signum);
flags = fcntl(fd, F_GETFL);
flags |= O_NONBLOCK|O_ASYNC;
fcntl(fd, F_SETFL, flags);
This sends that signal when a normal I/O function like read() or write() completes. To use this, write a normal poll() outer loop, and inside it, after you've handled all the fd's noticed by poll(), you loop calling sigwaitinfo().
If sigwaitinfo or sigtimedwait returns your realtime signal, siginfo.si_fd and siginfo.si_band give almost the same information as pollfd.fd and pollfd.revents would after a call to poll(), so you handle the i/o, and continue calling sigwaitinfo().
If sigwaitinfo returns a traditional SIGIO, the signal queue overflowed, so you flush the signal queue by temporarily changing the signal handler to SIG_DFL, and break back to the outer poll() loop. 
See Poller_sigio (cc, h) for an example of how to use rtsignals interchangeably with many other readiness notification schemes.

See Zach Brown's phhttpd for example code that uses this feature directly. (Or don't; phhttpd is a bit hard to figure out...)

[Provos, Lever, and Tweedie 2000] describes a recent benchmark of phhttpd using a variant of sigtimedwait(), sigtimedwait4(), that lets you retrieve multiple signals with one call. Interestingly, the chief benefit of sigtimedwait4() for them seemed to be it allowed the app to gauge system overload (so it could behave appropriately). (Note that poll() provides the same measure of system overload.)

Signal-per-fd
Chandra and Mosberger proposed a modification to the realtime signal approach called "signal-per-fd" which reduces or eliminates realtime signal queue overflow by coalescing redundant events. It doesn't outperform epoll, though. Their paper ( www.hpl.hp.com/techreports/2000/HPL-2000-174.html) compares performance of this scheme with select() and /dev/poll.
Vitaly Luban announced a patch implementing this scheme on 18 May 2001; his patch lives at www.luban.org/GPL/gpl.html. (Note: as of Sept 2001, there may still be stability problems with this patch under heavy load. dkftpbench at about 4500 users may be able to trigger an oops.)

See Poller_sigfd (cc, h) for an example of how to use signal-per-fd interchangeably with many other readiness notification schemes.

4.3. Serve many clients with each server thread, and use asynchronous I/O

This has not yet become popular in Unix, probably because few operating systems support asynchronous I/O, also possibly because it (like nonblocking I/O) requires rethinking your application. Under standard Unix, asynchronous I/O is provided by the aio_ interface (scroll down from that link to "Asynchronous input and output"), which associates a signal and value with each I/O operation. Signals and their values are queued and delivered efficiently to the user process. This is from the POSIX 1003.1b realtime extensions, and is also in the Single Unix Specification, version 2.

AIO is normally used with edge-triggered completion notification, i.e. a signal is queued when the operation is complete. (It can also be used with level triggered completion notification by calling aio_suspend(), though I suspect few people do this.)

glibc 2.1 and later provide a generic implementation written for standards compliance rather than performance.

Ben LaHaise's implementation for Linux AIO was merged into the main Linux kernel as of 2.5.32. It doesn't use kernel threads, and has a very efficient underlying api, but (as of 2.6.0-test2) doesn't yet support sockets. (There is also an AIO patch for the 2.4 kernels, but the 2.5/2.6 implementation is somewhat different.) More info:

The page "Kernel Asynchronous I/O (AIO) Support for Linux" which tries to tie together all info about the 2.6 kernel's implementation of AIO (posted 16 Sept 2003)
Round 3: aio vs /dev/epoll by Benjamin C.R. LaHaise (presented at 2002 OLS)
Asynchronous I/O Suport in Linux 2.5, by Bhattacharya, Pratt, Pulaverty, and Morgan, IBM; presented at OLS '2003
Design Notes on Asynchronous I/O (aio) for Linux by Suparna Bhattacharya -- compares Ben's AIO with SGI's KAIO and a few other AIO projects
Linux AIO home page - Ben's preliminary patches, mailing list, etc.
linux-aio mailing list archives
libaio-oracle - library implementing standard Posix AIO on top of libaio. First mentioned by Joel Becker on 18 Apr 2003.
Suparna also suggests having a look at the the DAFS API's approach to AIO.
Red Hat AS and Suse SLES both provide a high-performance implementation on the 2.4 kernel; it is related to, but not completely identical to, the 2.6 kernel implementation.

In February 2006, a new attempt is being made to provide network AIO; see the note above about Evgeniy Polyakov's kevent-based AIO.

In 1999, SGI implemented high-speed AIO for Linux. As of version 1.1, it's said to work well with both disk I/O and sockets. It seems to use kernel threads. It is still useful for people who can't wait for Ben's AIO to support sockets.

The O'Reilly book POSIX.4: Programming for the Real World is said to include a good introduction to aio.

A tutorial for the earlier, nonstandard, aio implementation on Solaris is online at Sunsite. It's probably worth a look, but keep in mind you'll need to mentally convert "aioread" to "aio_read", etc.

Note that AIO doesn't provide a way to open files without blocking for disk I/O; if you care about the sleep caused by opening a disk file, Linus suggests you should simply do the open() in a different thread rather than wishing for an aio_open() system call.

Under Windows, asynchronous I/O is associated with the terms "Overlapped I/O" and IOCP or "I/O Completion Port". Microsoft's IOCP combines techniques from the prior art like asynchronous I/O (like aio_write) and queued completion notification (like when using the aio_sigevent field with aio_write) with a new idea of holding back some requests to try to keep the number of running threads associated with a single IOCP constant. For more information, see Inside I/O Completion Ports by Mark Russinovich at sysinternals.com, Jeffrey Richter's book "Programming Server-Side Applications for Microsoft Windows 2000" (Amazon, MSPress), U.S. patent #06223207, or MSDN.

4.4. Serve one client with each server thread

... and let read() and write() block. Has the disadvantage of using a whole stack frame for each client, which costs memory. Many OS's also have trouble handling more than a few hundred threads. If each thread gets a 2MB stack (not an uncommon default value), you run out of *virtual memory* at (2^30 / 2^21) = 512 threads on a 32 bit machine with 1GB user-accessible VM (like, say, Linux as normally shipped on x86). You can work around this by giving each thread a smaller stack, but since most thread libraries don't allow growing thread stacks once created, doing this means designing your program to minimize stack use. You can also work around this by moving to a 64 bit processor.

The thread support in Linux, FreeBSD, and Solaris is improving, and 64 bit processors are just around the corner even for mainstream users. Perhaps in the not-too-distant future, those who prefer using one thread per client will be able to use that paradigm even for 10000 clients. Nevertheless, at the current time, if you actually want to support that many clients, you're probably better off using some other paradigm.

For an unabashedly pro-thread viewpoint, see Why Events Are A Bad Idea (for High-concurrency Servers) by von Behren, Condit, and Brewer, UCB, presented at HotOS IX. Anyone from the anti-thread camp care to point out a paper that rebuts this one? :-)

LinuxThreads

LinuxTheads is the name for the standard Linux thread library. It is integrated into glibc since glibc2.0, and is mostly Posix-compliant, but with less than stellar performance and signal support.
NGPT: Next Generation Posix Threads for Linux

NGPT is a project started by IBM to bring good Posix-compliant thread support to Linux. It's at stable version 2.2 now, and works well... but the NGPT team has announced that they are putting the NGPT codebase into support-only mode because they feel it's "the best way to support the community for the long term". The NGPT team will continue working to improve Linux thread support, but now focused on improving NPTL. (Kudos to the NGPT team for their good work and the graceful way they conceded to NPTL.)
NPTL: Native Posix Thread Library for Linux

NPTL is a project by Ulrich Drepper (the benevolent dict^H^H^H^Hmaintainer of glibc) and Ingo Molnar to bring world-class Posix threading support to Linux.
As of 5 October 2003, NPTL is now merged into the glibc cvs tree as an add-on directory (just like linuxthreads), so it will almost certainly be released along with the next release of glibc.

The first major distribution to include an early snapshot of NPTL was Red Hat 9. (This was a bit inconvenient for some users, but somebody had to break the ice...)

NPTL links:

Mailing list for NPTL discussion
NPTL source code
Initial announcement for NPTL
Original whitepaper describing the goals for NPTL
Revised whitepaper describing the final design of NPTL
Ingo Molnar's first benchmark showing it could handle 10^6 threads
Ulrich's benchmark comparing performance of LinuxThreads, NPTL, and IBM's NGPT. It seems to show NPTL is much faster than NGPT.
Here's my try at describing the history of NPTL (see also Jerry Cooperstein's article):
In March 2002, Bill Abt of the NGPT team, the glibc maintainer Ulrich Drepper, and others met to figure out what to do about LinuxThreads. One idea that came out of the meeting was to improve mutex performance; Rusty Russell et al subsequently implemented fast userspace mutexes (futexes)), which are now used by both NGPT and NPTL. Most of the attendees figured NGPT should be merged into glibc.

Ulrich Drepper, though, didn't like NGPT, and figured he could do better. (For those who have ever tried to contribute a patch to glibc, this may not come as a big surprise :-) Over the next few months, Ulrich Drepper, Ingo Molnar, and others contributed glibc and kernel changes that make up something called the Native Posix Threads Library (NPTL). NPTL uses all the kernel enhancements designed for NGPT, and takes advantage of a few new ones. Ingo Molnar described the kernel enhancements as follows:

While NPTL uses the three kernel features introduced by NGPT: getpid() returns PID, CLONE_THREAD and futexes; NPTL also uses (and relies on) a much wider set of new kernel features, developed as part of this project.
Some of the items NGPT introduced into the kernel around 2.5.8 got modified, cleaned up and extended, such as thread group handling (CLONE_THREAD). [the CLONE_THREAD changes which impacted NGPT's compatibility got synced with the NGPT folks, to make sure NGPT does not break in any unacceptable way.]

The kernel features developed for and used by NPTL are described in the design whitepaper, http://people.redhat.com/drepper/nptl-design.pdf ...

A short list: TLS support, various clone extensions (CLONE_SETTLS, CLONE_SETTID, CLONE_CLEARTID), POSIX thread-signal handling, sys_exit() extension (release TID futex upon VM-release), the sys_exit_group() system-call, sys_execve() enhancements and support for detached threads.

There was also work put into extending the PID space - eg. procfs crashed due to 64K PID assumptions, max_pid, and pid allocation scalability work. Plus a number of performance-only improvements were done as well.

In essence the new features are a no-compromises approach to 1:1 threading - the kernel now helps in everything where it can improve threading, and we precisely do the minimally necessary set of context switches and kernel calls for every basic threading primitive.

One big difference between the two is that NPTL is a 1:1 threading model, whereas NGPT is an M:N threading model (see below). In spite of this, Ulrich's initial benchmarks seem to show that NPTL is indeed much faster than NGPT. (The NGPT team is looking forward to seeing Ulrich's benchmark code to verify the result.)
FreeBSD threading support

FreeBSD supports both LinuxThreads and a userspace threading library. Also, a M:N implementation called KSE was introduced in FreeBSD 5.0. For one overview, see www.unobvious.com/bsd/freebsd-threads.html.
On 25 Mar 2003, Jeff Roberson posted on freebsd-arch:

... Thanks to the foundation provided by Julian, David Xu, Mini, Dan Eischen, and everyone else who has participated with KSE and libpthread development Mini and I have developed a 1:1 threading implementation. This code works in parallel with KSE and does not break it in any way. It actually helps bring M:N threading closer by testing out shared bits. ...
And in July 2006, Robert Watson proposed that the 1:1 threading implementation become the default in FreeBsd 7.x:
I know this has been discussed in the past, but I figured with 7.x trundling forward, it was time to think about it again. In benchmarks for many common applications and scenarios, libthr demonstrates significantly better performance over libpthread... libthr is also implemented across a larger number of our platforms, and is already libpthread on several. The first recommendation we make to MySQL and other heavy thread users is "Switch to libthr", which is suggestive, also! ... So the strawman proposal is: make libthr the default threading library on 7.x.
NetBSD threading support

According to a note from Noriyuki Soda:
Kernel supported M:N thread library based on the Scheduler Activations model is merged into NetBSD-current on Jan 18 2003.
For details, see An Implementation of Scheduler Activations on the NetBSD Operating System by Nathan J. Williams, Wasabi Systems, Inc., presented at FREENIX '02.
Solaris threading support

The thread support in Solaris is evolving... from Solaris 2 to Solaris 8, the default threading library used an M:N model, but Solaris 9 defaults to 1:1 model thread support. See Sun's multithreaded programming guide and Sun's note about Java and Solaris threading.
Java threading support in JDK 1.3.x and earlier

As is well known, Java up to JDK1.3.x did not support any method of handling network connections other than one thread per client. Volanomark is a good microbenchmark which measures throughput in messsages per second at various numbers of simultaneous connections. As of May 2003, JDK 1.3 implementations from various vendors are in fact able to handle ten thousand simultaneous connections -- albeit with significant performance degradation. See Table 4 for an idea of which JVMs can handle 10000 connections, and how performance suffers as the number of connections increases.
Note: 1:1 threading vs. M:N threading

There is a choice when implementing a threading library: you can either put all the threading support in the kernel (this is called the 1:1 threading model), or you can move a fair bit of it into userspace (this is called the M:N threading model). At one point, M:N was thought to be higher performance, but it's so complex that it's hard to get right, and most people are moving away from it.
Why Ingo Molnar prefers 1:1 over M:N
Sun is moving to 1:1 threads
NGPT is an M:N threading library for Linux.
Although Ulrich Drepper planned to use M:N threads in the new glibc threading library, he has since switched to the 1:1 threading model.
MacOSX appears to use 1:1 threading.
FreeBSD and NetBSD appear to still believe in M:N threading... The lone holdouts? Looks like freebsd 7.0 might switch to 1:1 threading (see above), so perhaps M:N threading's believers have finally been proven wrong everywhere.
4.5. Build the server code into the kernel

Novell and Microsoft are both said to have done this at various times, at least one NFS implementation does this, khttpd does this for Linux and static web pages, and "TUX" (Threaded linUX webserver) is a blindingly fast and flexible kernel-space HTTP server by Ingo Molnar for Linux. Ingo's September 1, 2000 announcement says an alpha version of TUX can be downloaded from ftp://ftp.redhat.com/pub/redhat/tux, and explains how to join a mailing list for more info. 
The linux-kernel list has been discussing the pros and cons of this approach, and the consensus seems to be instead of moving web servers into the kernel, the kernel should have the smallest possible hooks added to improve web server performance. That way, other kinds of servers can benefit. See e.g. Zach Brown's remarks about userland vs. kernel http servers. It appears that the 2.4 linux kernel provides sufficient power to user programs, as the X15 server runs about as fast as Tux, but doesn't use any kernel modifications.

5 Comments

Richard Gooch has written a paper discussing I/O options.

In 2001, Tim Brecht and MMichal Ostrowski measured various strategies for simple select-based servers. Their data is worth a look.

In 2003, Tim Brecht posted source code for userver, a small web server put together from several servers written by Abhishek Chandra, David Mosberger, David Pariag, and Michal Ostrowski. It can use select(), poll(), epoll(), or sigio.

Back in March 1999, Dean Gaudet posted:

I keep getting asked "why don't you guys use a select/event based model like Zeus? It's clearly the fastest." ...
His reasons boiled down to "it's really hard, and the payoff isn't clear". Within a few months, though, it became clear that people were willing to work on it.
Mark Russinovich wrote an editorial and an article discussing I/O strategy issues in the 2.2 Linux kernel. Worth reading, even he seems misinformed on some points. In particular, he seems to think that Linux 2.2's asynchronous I/O (see F_SETSIG above) doesn't notify the user process when data is ready, only when new connections arrive. This seems like a bizarre misunderstanding. See also comments on an earlier draft, Ingo Molnar's rebuttal of 30 April 1999, Russinovich's comments of 2 May 1999, a rebuttal from Alan Cox, and various posts to linux-kernel. I suspect he was trying to say that Linux doesn't support asynchronous disk I/O, which used to be true, but now that SGI has implemented KAIO, it's not so true anymore.

See these pages at sysinternals.com and MSDN for information on "completion ports", which he said were unique to NT; in a nutshell, win32's "overlapped I/O" turned out to be too low level to be convenient, and a "completion port" is a wrapper that provides a queue of completion events, plus scheduling magic that tries to keep the number of running threads constant by allowing more threads to pick up completion events if other threads that had picked up completion events from this port are sleeping (perhaps doing blocking I/O).

See also OS/400's support for I/O completion ports.

There was an interesting discussion on linux-kernel in September 1999 titled "> 15,000 Simultaneous Connections" (and the second week of the thread). Highlights:

Ed Hall posted a few notes on his experiences; he's achieved >1000 connects/second on a UP P2/333 running Solaris. His code used a small pool of threads (1 or 2 per CPU) each managing a large number of clients using "an event-based model".
Mike Jagdis posted an analysis of poll/select overhead, and said "The current select/poll implementation can be improved significantly, especially in the blocking case, but the overhead will still increase with the number of descriptors because select/poll does not, and cannot, remember what descriptors are interesting. This would be easy to fix with a new API. Suggestions are welcome..."
Mike posted about his work on improving select() and poll().
Mike posted a bit about a possible API to replace poll()/select(): "How about a 'device like' API where you write 'pollfd like' structs, the 'device' listens for events and delivers 'pollfd like' structs representing them when you read it? ... "
Rogier Wolff suggested using "the API that the digital guys suggested", http://www.cs.rice.edu/~gaurav/papers/usenix99.ps
Joerg Pommnitz pointed out that any new API along these lines should be able to wait for not just file descriptor events, but also signals and maybe SYSV-IPC. Our synchronization primitives should certainly be able to do what Win32's WaitForMultipleObjects can, at least.
Stephen Tweedie asserted that the combination of F_SETSIG, queued realtime signals, and sigwaitinfo() was a superset of the API proposed in http://www.cs.rice.edu/~gaurav/papers/usenix99.ps. He also mentions that you keep the signal blocked at all times if you're interested in performance; instead of the signal being delivered asynchronously, the process grabs the next one from the queue with sigwaitinfo().
Jayson Nordwick compared completion ports with the F_SETSIG synchronous event model, and concluded they're pretty similar.
Alan Cox noted that an older rev of SCT's SIGIO patch is included in 2.3.18ac.
Jordan Mendelson posted some example code showing how to use F_SETSIG.
Stephen C. Tweedie continued the comparison of completion ports and F_SETSIG, and noted: "With a signal dequeuing mechanism, your application is going to get signals destined for various library components if libraries are using the same mechanism," but the library can set up its own signal handler, so this shouldn't affect the program (much).
Doug Royer noted that he'd gotten 100,000 connections on Solaris 2.6 while he was working on the Sun calendar server. Others chimed in with estimates of how much RAM that would require on Linux, and what bottlenecks would be hit.
Interesting reading!

6 Limits on open filehandles

Any Unix: the limits set by ulimit or setrlimit.
Solaris: see the Solaris FAQ, question 3.46 (or thereabouts; they renumber the questions periodically).
FreeBSD:

Edit /boot/loader.conf, add the line
set kern.maxfiles=XXXX
where XXXX is the desired system limit on file descriptors, and reboot. Thanks to an anonymous reader, who wrote in to say he'd achieved far more than 10000 connections on FreeBSD 4.3, and says
"FWIW: You can't actually tune the maximum number of connections in FreeBSD trivially, via sysctl.... You have to do it in the /boot/loader.conf file. 
The reason for this is that the zalloci() calls for initializing the sockets and tcpcb structures zones occurs very early in system startup, in order that the zone be both type stable and that it be swappable. 
You will also need to set the number of mbufs much higher, since you will (on an unmodified kernel) chew up one mbuf per connection for tcptempl structures, which are used to implement keepalive."
Another reader says
"As of FreeBSD 4.4, the tcptempl structure is no longer allocated; you no longer have to worry about one mbuf being chewed up per connection."
See also:
the FreeBSD handbook
SYSCTL TUNING, LOADER TUNABLES, and KERNEL CONFIG TUNING in 'man tuning'
The Effects of Tuning a FreeBSD 4.3 Box for High Performance, Daemon News, Aug 2001
postfix.org tuning notes, covering FreeBSD 4.2 and 4.4
the Measurement Factory's notes, circa FreeBSD 4.3
OpenBSD: A reader says
"In OpenBSD, an additional tweak is required to increase the number of open filehandles available per process: the openfiles-cur parameter in /etc/login.conf needs to be increased. You can change kern.maxfiles either with sysctl -w or in sysctl.conf but it has no effect. This matters because as shipped, the login.conf limits are a quite low 64 for nonprivileged processes, 128 for privileged."
Linux: See Bodo Bauer's /proc documentation. On 2.4 kernels:
echo 32768 > /proc/sys/fs/file-max
increases the system limit on open files, and
ulimit -n 32768
increases the current process' limit.
On 2.2.x kernels,

echo 32768 > /proc/sys/fs/file-max
echo 65536 > /proc/sys/fs/inode-max
increases the system limit on open files, and
ulimit -n 32768
increases the current process' limit.
I verified that a process on Red Hat 6.0 (2.2.5 or so plus patches) can open at least 31000 file descriptors this way. Another fellow has verified that a process on 2.2.12 can open at least 90000 file descriptors this way (with appropriate limits). The upper bound seems to be available memory. 
Stephen C. Tweedie posted about how to set ulimit limits globally or per-user at boot time using initscript and pam_limit. 
In older 2.2 kernels, though, the number of open files per process is still limited to 1024, even with the above changes. 
See also Oskar's 1998 post, which talks about the per-process and system-wide limits on file descriptors in the 2.0.36 kernel.

7 Limits on threads

On any architecture, you may need to reduce the amount of stack space allocated for each thread to avoid running out of virtual memory. You can set this at runtime with pthread_attr_init() if you're using pthreads.

Solaris: it supports as many threads as will fit in memory, I hear.
Linux 2.6 kernels with NPTL: /proc/sys/vm/max_map_count may need to be increased to go above 32000 or so threads. (You'll need to use very small stack threads to get anywhere near that number of threads, though, unless you're on a 64 bit processor.) See the NPTL mailing list, e.g. the thread with subject "Cannot create more than 32K threads?", for more info.
Linux 2.4: /proc/sys/kernel/threads-max is the max number of threads; it defaults to 2047 on my Red Hat 8 system. You can set increase this as usual by echoing new values into that file, e.g. "echo 4000 > /proc/sys/kernel/threads-max"
Linux 2.2: Even the 2.2.13 kernel limits the number of threads, at least on Intel. I don't know what the limits are on other architectures. Mingo posted a patch for 2.1.131 on Intel that removed this limit. It appears to be integrated into 2.3.20.
See also Volano's detailed instructions for raising file, thread, and FD_SET limits in the 2.2 kernel. Wow. This document steps you through a lot of stuff that would be hard to figure out yourself, but is somewhat dated.

Java: See Volano's detailed benchmark info, plus their info on how to tune various systems to handle lots of threads.

8 Java issues

Up through JDK 1.3, Java's standard networking libraries mostly offered the one-thread-per-client model. There was a way to do nonblocking reads, but no way to do nonblocking writes.

In May 2001, JDK 1.4 introduced the package java.nio to provide full support for nonblocking I/O (and some other goodies). See the release notes for some caveats. Try it out and give Sun feedback!

HP's java also includes a Thread Polling API.

In 2000, Matt Welsh implemented nonblocking sockets for Java; his performance benchmarks show that they have advantages over blocking sockets in servers handling many (up to 10000) connections. His class library is called java-nbio; it's part of the Sandstorm project. Benchmarks showing performance with 10000 connections are available.

See also Dean Gaudet's essay on the subject of Java, network I/O, and threads, and the paper by Matt Welsh on events vs. worker threads.

Before NIO, there were several proposals for improving Java's networking APIs:

Matt Welsh's Jaguar system proposes preserialized objects, new Java bytecodes, and memory management changes to allow the use of asynchronous I/O with Java.
Interfacing Java to the Virtual Interface Architecture, by C-C. Chang and T. von Eicken, proposes memory management changes to allow the use of asynchronous I/O with Java.
JSR-51 was the Sun project that came up with the java.nio package. Matt Welsh participated (who says Sun doesn't listen?).

9 Other tips

Zero-Copy
Normally, data gets copied many times on its way from here to there. Any scheme that eliminates these copies to the bare physical minimum is called "zero-copy".
Thomas Ogrisegg's zero-copy send patch for mmaped files under Linux 2.4.17-2.4.20. Claims it's faster than sendfile().
IO-Lite is a proposal for a set of I/O primitives that gets rid of the need for many copies.
Alan Cox noted that zero-copy is sometimes not worth the trouble back in 1999. (He did like sendfile(), though.)
Ingo implemented a form of zero-copy TCP in the 2.4 kernel for TUX 1.0 in July 2000, and says he'll make it available to userspace soon.
Drew Gallatin and Robert Picco have added some zero-copy features to FreeBSD; the idea seems to be that if you call write() or read() on a socket, the pointer is page-aligned, and the amount of data transferred is at least a page, *and* you don't immediately reuse the buffer, memory management tricks will be used to avoid copies. But see followups to this message on linux-kernel for people's misgivings about the speed of those memory management tricks.
According to a note from Noriyuki Soda:

Sending side zero-copy is supported since NetBSD-1.6 release by specifying "SOSEND_LOAN" kernel option. This option is now default on NetBSD-current (you can disable this feature by specifying "SOSEND_NO_LOAN" in the kernel option on NetBSD_current). With this feature, zero-copy is automatically enabled, if data more than 4096 bytes are specified as data to be sent.
The sendfile() system call can implement zero-copy networking.
The sendfile() function in Linux and FreeBSD lets you tell the kernel to send part or all of a file. This lets the OS do it as efficiently as possible. It can be used equally well in servers using threads or servers using nonblocking I/O. (In Linux, it's poorly documented at the moment; use _syscall4 to call it. Andi Kleen is writing new man pages that cover this. See also Exploring The sendfile System Call by Jeff Tranter in Linux Gazette issue 91.) Rumor has it, ftp.cdrom.com benefitted noticeably from sendfile().
A zero-copy implementation of sendfile() is on its way for the 2.4 kernel. See LWN Jan 25 2001.

One developer using sendfile() with Freebsd reports that using POLLWRBAND instead of POLLOUT makes a big difference.

Solaris 8 (as of the July 2001 update) has a new system call 'sendfilev'. A copy of the man page is here.. The Solaris 8 7/01 release notes also mention it. I suspect that this will be most useful when sending to a socket in blocking mode; it'd be a bit of a pain to use with a nonblocking socket.

Avoid small frames by using writev (or TCP_CORK)
A new socket option under Linux, TCP_CORK, tells the kernel to avoid sending partial frames, which helps a bit e.g. when there are lots of little write() calls you can't bundle together for some reason. Unsetting the option flushes the buffer. Better to use writev(), though...
See LWN Jan 25 2001 for a summary of some very interesting discussions on linux-kernel about TCP_CORK and a possible alternative MSG_MORE.

Behave sensibly on overload.
[Provos, Lever, and Tweedie 2000] notes that dropping incoming connections when the server is overloaded improved the shape of the performance curve, and reduced the overall error rate. They used a smoothed version of "number of clients with I/O ready" as a measure of overload. This technique should be easily applicable to servers written with select, poll, or any system call that returns a count of readiness events per call (e.g. /dev/poll or sigtimedwait4()).
Some programs can benefit from using non-Posix threads.
Not all threads are created equal. The clone() function in Linux (and its friends in other operating systems) lets you create a thread that has its own current working directory, for instance, which can be very helpful when implementing an ftp server. See Hoser FTPd for an example of the use of native threads rather than pthreads.
Caching your own data can sometimes be a win.
"Re: fix for hybrid server problems" by Vivek Sadananda Pai (vivek@cs.rice.edu) on new-httpd, May 9th, states:
"I've compared the raw performance of a select-based server with a multiple-process server on both FreeBSD and Solaris/x86. On microbenchmarks, there's only a marginal difference in performance stemming from the software architecture. The big performance win for select-based servers stems from doing application-level caching. While multiple-process servers can do it at a higher cost, it's harder to get the same benefits on real workloads (vs microbenchmarks). I'll be presenting those measurements as part of a paper that'll appear at the next Usenix conference. If you've got postscript, the paper is available at http://www.cs.rice.edu/~vivek/flash99/"

10 Other limits

Old system libraries might use 16 bit variables to hold file handles, which causes trouble above 32767 handles. glibc2.1 should be ok.
Many systems use 16 bit variables to hold process or thread id's. It would be interesting to port the Volano scalability benchmark to C, and see what the upper limit on number of threads is for the various operating systems.
Too much thread-local memory is preallocated by some operating systems; if each thread gets 1MB, and total VM space is 2GB, that creates an upper limit of 2000 threads.
Look at the performance comparison graph at the bottom of http://www.acme.com/software/thttpd/benchmarks.html. Notice how various servers have trouble above 128 connections, even on Solaris 2.6? Anyone who figures out why, let me know. 
Note: if the TCP stack has a bug that causes a short (200ms) delay at SYN or FIN time, as Linux 2.2.0-2.2.6 had, and the OS or http daemon has a hard limit on the number of connections open, you would expect exactly this behavior. There may be other causes.

11 Kernel Issues

For Linux, it looks like kernel bottlenecks are being fixed constantly. See Linux Weekly News, Kernel Traffic, the Linux-Kernel mailing list, and my Mindcraft Redux page.

In March 1999, Microsoft sponsored a benchmark comparing NT to Linux at serving large numbers of http and smb clients, in which they failed to see good results from Linux. See also my article on Mindcraft's April 1999 Benchmarks for more info.

See also The Linux Scalability Project. They're doing interesting work, including Niels Provos' hinting poll patch, and some work on the thundering herd problem.

See also Mike Jagdis' work on improving select() and poll(); here's Mike's post about it.

Mohit Aron (aron@cs.rice.edu) writes that rate-based clocking in TCP can improve HTTP response time over 'slow' connections by 80%.

12 Measuring Server Performance

Two tests in particular are simple, interesting, and hard:

raw connections per second (how many 512 byte files per second can you serve?)
total transfer rate on large files with many slow clients (how many 28.8k modem clients can simultaneously download from your server before performance goes to pot?)
Jef Poskanzer has published benchmarks comparing many web servers. See http://www.acme.com/software/thttpd/benchmarks.html for his results.

I also have a few old notes about comparing thttpd to Apache that may be of interest to beginners.

Chuck Lever keeps reminding us about Banga and Druschel's paper on web server benchmarking. It's worth a read.

IBM has an excellent paper titled Java server benchmarks [Baylor et al, 2000]. It's worth a read.

Examples

Interesting select()-based servers

thttpd Very simple. Uses a single process. It has good performance, but doesn't scale with the number of CPU's. Can also use kqueue.
mathopd. Similar to thttpd.
fhttpd
boa
Roxen
Zeus, a commercial server that tries to be the absolute fastest. See their tuning guide.
The other non-Java servers listed at http://www.acme.com/software/thttpd/benchmarks.html
BetaFTPd
Flash-Lite - web server using IO-Lite.
Flash: An efficient and portable Web server -- uses select(), mmap(), mincore()
The Flash web server as of 2003 -- uses select(), modified sendfile(), async open()
xitami - uses select() to implement its own thread abstraction for portability to systems without threads.
Medusa - a server-writing toolkit in Python that tries to deliver very high performance.
userver - a small http server that can use select, poll, epoll, or sigio
Interesting /dev/poll-based servers

N. Provos, C. Lever, "Scalable Network I/O in Linux," May, 2000. [FREENIX track, Proc. USENIX 2000, San Diego, California (June, 2000).] Describes a version of thttpd modified to support /dev/poll. Performance is compared with phhttpd.
Interesting kqueue()-based servers

thttpd (as of version 2.21?)
Adrian Chadd says "I'm doing a lot of work to make squid actually LIKE a kqueue IO system"; it's an official Squid subproject; see http://squid.sourceforge.net/projects.html#commloops. (This is apparently newer than Benno's patch.)
Interesting realtime signal-based servers

Chromium's X15. This uses the 2.4 kernel's SIGIO feature together with sendfile() and TCP_CORK, and reportedly achieves higher speed than even TUX. The source is available under a community source (not open source) license. See the original announcement by Fabio Riccardi.
Zach Brown's phhttpd - "a quick web server that was written to showcase the sigio/siginfo event model. consider this code highly experimental and yourself highly mental if you try and use it in a production environment." Uses the siginfo features of 2.3.21 or later, and includes the needed patches for earlier kernels. Rumored to be even faster than khttpd. See his post of 31 May 1999 for some notes.
Interesting thread-based servers

Hoser FTPD. See their benchmark page.
Peter Eriksson's phttpd and
pftpd
The Java-based servers listed at http://www.acme.com/software/thttpd/benchmarks.html
Sun's Java Web Server (which has been reported to handle 500 simultaneous clients)
Interesting in-kernel servers

khttpd
"TUX" (Threaded linUX webserver) by Ingo Molnar et al. For 2.4 kernel.
Other interesting links

Jeff Darcy's notes on high-performance server design
Ericsson's ARIES project -- benchmark results for Apache 1 vs. Apache 2 vs. Tomcat on 1 to 12 processors
Prof. Peter Ladkin's Web Server Performance page.
Novell's FastCache -- claims 10000 hits per second. Quite the pretty performance graph.
Rik van Riel's Linux Performance Tuning site
Changelog

$Log: c10k.html,v $
Revision 1.212  2006/09/02 14:52:13  dank
added asio

Revision 1.211  2006/07/27 10:28:58  dank
Link to Cal Henderson's book.

Revision 1.210  2006/07/27 10:18:58  dank
Listify polyakov links, add Drepper's new proposal, note that FreeBSD 7 might move to 1:1

Revision 1.209  2006/07/13 15:07:03  dank
link to Scale! library, updated Polyakov links

Revision 1.208  2006/07/13 14:50:29  dank
Link to Polyakov's patches

Revision 1.207  2003/11/03 08:09:39  dank
Link to Linus's message deprecating the idea of aio_open

Revision 1.206  2003/11/03 07:44:34  dank
link to userver

Revision 1.205  2003/11/03 06:55:26  dank
Link to Vivek Pei's new Flash paper, mention great specweb99 score

Copyright 1999-2006 Dan Kegel
dank@kegel.com
Last updated: 2 Sept 2006
[Return to www.kegel.com]

如今的web服务器需要同时处理一万个以上的客户端了，难道不是吗？毕竟如今的网络上访问量已经非常巨大了。
现在的计算机非常强大，你只需要花大概$1200就可以买一个1000MHz的处理器，2G的内存， 1000Mbit/sec的网卡的机器。让我们来看看--20000个客户，每个为50KHz，100Kbyes和 50Kbit/sec，那么没有什么比为这两万个客户端的每个每秒从硬盘读取4千字节然后发送到网络上去更消耗资源的了。可以看出硬件不再是瓶颈了。 (That works out to $0.08 per client, by the way. Those $100/client licensing fees some operating systems charge are starting to look a little heavy!)
在1999年最繁忙的ftp站点，cdrom.com，尽管有上G比特的网络带宽，却也只能同时处理10000个客户端。在2001年，同样的速度可以被几个ISP服务商所提供，预期该趋势会因为大量的商业用户而变得越来越普遍。
目前的瘦客户端模型也开始再次变得流行起来了――这一次是服务器运行在Internet上，为数千个客户端服务。
基于以上一些考虑，这里就配置操作系统或者编写支持数千个网络客户端的代码问题提出一些需要加以注意的地方，讨论的范围是我比较感兴趣的类Unix操作系统，当然我也喜欢Windows。
内容
·                     The C10K problem
·                     相关站点
·                     须首先阅读的书籍
·                     I/O框架
·                     I/O策略
1.                用一个线程来服务多个客户, 使用非阻塞 I/O （nonblocking I/O）和水平触发[译注：也有文档译成条件触发]的就绪通知（ level-triggered readiness notification）
§                传统的 select()
§                传统的 poll()
§                /dev/poll (Solaris 2.7+)
§                kqueue (FreeBSD, NetBSD)
2.                用一个线程来服务多个客户,使用非阻塞的I/O和就绪变化通知（ readiness change notification）
§                epoll (Linux 2.6+)
§                Polyakov's kevent (Linux 2.6+)
§                Drepper's New Network Interface (proposal for Linux 2.6+)
§                实时信号 (Linux 2.4+)
§                每个fd一个信号
§                kqueue (FreeBSD, NetBSD)
3.                一个客户一个线程模式, 使用异步I/O和完成通知（ completion notification）
4.                一个客户一个服务器线程模式
§                LinuxThreads (Linux 2.0+)
§                NGPT (Linux 2.4+)
§                NPTL (Linux 2.6, Red Hat 9)
§                FreeBSD 对线程的支持
§                NetBSD 对线程的支持
§                Solaris对线程的支持
§                Java JDK 1.3 和早期的对线程的支持
§                Note: 1:1 线程模型 vs. M:N 线程模型
5.                把服务器代码编译进内核
·                     重要注释
·                     打开文件句柄数目上的限制
·                     线程上的限制
·                     Java 问题 [更新到 27 May 2001]
·                     Other tips
o                  零拷贝
o                  调用 sendfile()来实现网络上的零拷贝技术
o                  使用writev (or TCP_CORK)避免小的帧
o                  受益于使用非Posix线程的程序
o                  缓存你的数据有时会使性能提升
·                     其它限制
·                     核心问题
·                     测试服务器性能
·                     例子
l 值得关注的基于select()服务器
l 值得关注的基于/dev/poll的服务器
l 值得关注的基于kqueue()的服务器
l 值得关注的基于实时信号的服务器
l 值得关注的基于线程的服务器
l 值得关注的内核中的服务器
·                     其它值得关注的链接
相关站点
2003年10月，Felix von Leitner整理了一个很好的网站和一个 presentation[译注：指Felix von Leitner所写的关于scalable network programming 的主题]，该网站介绍了网络(程序)的可伸缩性，完成了以不同网络系统调用和不同的操作系统为基准的性能比较。其中一项就是2.6版本的Linux内核击败了2.4的内核，当然还有许多的测试图表可以给OS的开发者在平时提供点参考。(See also the Slashdot comments; it'll be interesting to see whether anyone does followup benchmarks improving on Felix's results.)
 
需首先阅读的书籍
如果你还没有读过W.Richard Stevens先生的《Unix网络编程:第一卷》的话，推荐阅读，该书描述了许多关于编写高性能的服务器的I/O策略和各自的一些缺陷，甚至还讲述了"thundering herd"问题，同时你也可以阅读 Jeff Darcy写的关于高性能服务器设计的一些观点。
(另外有一本书会非常有用，特别是对那些使用而不是开发web服务器程序的人。这本书是由Cal Henderson 所著的《Building Scalable Web Sites》.)
I/O框架
以下所列的为几个包装好的库，它们抽象出了一些下面所表达的技术，并且可以使你的代码与具体操作系统隔离，从而具有更好的移植性。
·                     ACE, 一个重量级的C++ I/O框架，用面向对象实现了一些I/O策略和其它有用的东西，特别的，它的Reactor框架是用OO方式处理非阻塞I/O，而Proactor框架是用OO方式处理异步I/O的。
·                     ASIO 一个C++的I/O框架，正在成为Boost库的一部分。它像是ACE过渡到STL时代。（译注：ACE内部有自己的容器实现，它和C++ 标准库中的容器是不兼容的。）
·                     libevent 由Niels Provos用C 语言编写的一个轻量级的I/O框架。它支持kqueue和select，并且很快就可以支持poll和epoll(翻译此文时已经支持)。我想它应该是只采用了水平触发机制，该机制功过参半。Niels给出了一张图 来说明时间和连接数目在处理一个事件上的功能，从图上可以看出kqueue和sys_epoll明显胜出。
·                     我本人也尝试过写一个轻量级的框架(很可惜没有维持至今):
o                  Poller 是一个轻量级的C++ I/O框架，它使用任何一种准备就绪API(poll, select, /dev/poll, kqueue, sigio)实现水平触发准备就绪API。以其它不同的API为基准，Poller的性能好得多。该链接文档的下面一部分说明了如何使用这些准备就绪API。
o                  rn 是一个轻量级的C I/O框架，也是我继Poller后的第二个框架。该框架可以很容易的被用于商业应用中，也容易的适用于非C++应用中。它如今已经在几个商业产品中使用。
·                     2000年4月，Matt Welsh就构建服务器如何平衡工作线程和事件驱动技术的使用方面写了一篇论文，在该论文中描述了他自己的Sandstorm I/O框架。
·                     Cory Nelson's Scale! library - 一个Windows下的异步套接字，文件和管道的I/O库。
I/O 策略
网络软件设计者往往有很多种选择，以下列出一些：
·                     是否处理多个I/O？如何处理在单一线程中的多个I/O调用？
o                  不处理，从头到尾使用阻塞和同步I/O调用，可以使用多线程或多进程来达到并发效果。
o                  使用非阻塞调用（如在一个设置O_NONBLOCK选项的socket上使用write）读取I/O，当I/O完成时发出通知（如poll，/dev/poll）从而开始下一个I/O。这种主要使用在网络I/O上，而不是磁盘的I/O上。
o                  使用异步调用（如aio_write()）读取I/O，当I/O完成时会发出通知（如信号或者完成端口），可以同时使用在网络I/O和磁盘I/O上。
·                     如何控制对每个客户的服务?
对每个客户使用一个进程（经典的Unix方法，自从1980年一直使用）
一个系统级的线程处理多个客户，每个客户是如下一种：
l 一种用户级的线程(e.g. GNU state threads, classic Java with green threads)
l 一个状态机 (a bit esoteric, but popular in some circles; my favorite)
l a continuation (a bit esoteric, but popular in some circles)
一个系统级的线程对应一个来自客户端的连接(e.g. classic Java with native threads)
一个系统级的线程对应每一个活动的客户端连接(e.g. Tomcat with apache front end; NT完成端口; 线程池)
·                     是否使用标准的操作系统服务，还是把一些代码放入内核中（如自定义驱动，内核模块，VxD）。
下面的五种组合应该是最常用的了。
1.      一个线程服务多个客户端，使用非阻塞I/O和水平触发的就绪通知
2.      一个线程服务多个客户端，使用非阻塞I/O和就绪改变时通知
3.      一个服务线程服务多个客户端，使用异步I/O
4.      一个服务线程服务一个客户端，使用阻塞I/O
5.      把服务器代码编译进内核
1. 一个线程服务多个客户端，使用非阻塞I/O和水平触发的就绪通知
...把所有的套接字设置为工作在非阻塞模式下，然后使用select()或poll()来告知哪个句柄已有数据在等待处理。此模型是最传统的，在此模型下，由内核告知你某个文件描述符是否准备好，是否已经完成你的任务自从上次内核告知已准备好以来（“水平触发”这个名字来源计算机硬件设计，与其相对的是“边缘触发”，Jonathon Lemon在它的BSDCON 2000 paper on kqueue()论文中介绍了这两个术语）。
注意：牢记内核的就绪通知仅仅只是个提示，当你试图从一个文件描述符读取数据时，该文件描述符可能并没有准备好。这就是为什么需要在使用就绪通知的时候使用非阻塞模型的原因。
一个重要的瓶颈是read()或sendfile()从磁盘块读取时，如果该页当前并不在内存中。设置磁盘文件描述符为非阻塞没有任何影响。同样的问题也发生在内存映射磁盘文件中。首先一个服务需要磁盘I/O时，进程块和所有的客户端都必须等待，因此最初的非线程的性能就被消耗了。
这也是异步I/O的目的，当然仅限于没有AIO的系统。处理磁盘I/O的工作线程或工作进程也可能遭遇此瓶颈。一条途径就是使用内存映射文件，如果mincore()指明I/O必需的话，那么要求一个工作线程来完成此I/O，然后继续处理网络事件。Jef Poskanzer提到Pai，Druschel和Zwaenepoel的 Flash web服务器使用了这个方法，并且他们就此在 Usenix'99上做了一个演讲，看上去就好像 FreeBSD和Solaris 中提供了mincore()一样，但是它并不是Single Unix Specification的一部分，在Linux的2.3.51的内核中提供了该方法，感谢Chuck Lever。
在2003.11的 freebsd-hackers list中，Vivek Pei上报了一个不错的成果，他们利用系统剖析工具剖析它们的Flash Web服务器，然后再攻击其瓶颈。其中找到的一个瓶颈就是mincore（想来mincore已经不再是一个好办法了。），另外一个就是sendfile在磁盘块访问时的阻塞。通过引进修改过的sendfile()，当需要读取的页还没有在内存中时则返回类似EWOULDBLOCK的值，从而提高了性能。
The end result of their optimizations is a SpecWeb99 score of about 800 on a 1GHZ/1GB FreeBSD box, which is better than anything on file at spec.org.
在非阻塞套接字的集合中，关于单一线程是如何告知哪个套接字是I/O准备就绪的，以下列出了几种方法:
·                     传统的select()
·                     遗憾的是，select()受限于FD_SETSIZE个句柄。该限制被编译进了标准库和用户程序（有些版本的C library允许你在用户程序编译时放宽该限制）。
See Poller_select (cc, h) for an example of how to use select() interchangeably with other readiness notification schemes.
·                     传统的poll()
·                     虽然poll()能够处理的文件描述符个数没有硬编码限制，但是当有数千个时速度就会变得很慢，因为大多数的文件描述符在某个时间是空闲的，彻底扫描数千个描述符是需要花费一定时间的。
有些操作系统（如Solaris 8）通过使用了poll hinting技术改进了poll()，该技术由Niels Provos在1999年实现并利用基准测试程序测试过。
See Poller_poll (cc, h, benchmarks) for an example of how to use poll() interchangeably with other readiness notification schemes.
·                     /dev/poll
·                     这是在Solaris中被推荐的代替poll的方法。
/dev/poll的背后思想就是利用poll()在大部分的调用时使用相同的参数。使用/dev/poll时，首先打开/dev/poll得到文件描述符，然后把你关心的文件描述符写入到/dev/poll的描述符，然后你就可以从/dev/poll的描述符中读取到已就绪的文件描述符。
/dev/poll 在Solaris 7(see patchid 106541) 中就已经存在，不过在Solaris 8 中才公开现身。在750个客户端的情况下，this has 10% of the overhead of poll()。
关于/dev/poll在Linux上有多种不同的尝试实现，但是没有一种可以和epoll相比，不推荐在 Linux上使用/dev/poll。
See Poller_devpoll (cc, h benchmarks ) for an example of how to use /dev/poll interchangeably with many other readiness notification schemes. (Caution - the example is for Linux /dev/poll, might not work right on Solaris.)
·                     kqueue()
·                     这是在FreeBSD系统上推荐使用的代替poll的方法(and, soon, NetBSD).
kqueue()即可以水平触发，也可以边缘触发，具体请看下面.
2. 一个线程服务多个客户端，使用非阻塞I/O和就绪改变时通知
Readiness change notification（或边缘触发就绪通知）（goldou：就绪变化通知）的意思就是当你提供给内核一个文件描述符，一段时间后，如果该文件描述符从没有就绪到已经准备就绪，那么内核就会发出通知，告知该文件描述符已经就绪，并且不会再对该描述符发出类似的就绪通知直到你在描述符上进行一些操作使得该描述符不再就绪（如直到在send，recv或者accept等调用上遇到EWOULDBLOCK错误，或者发送/接收了少于需要的字节数）。
当使用Readiness change notification时，必须准备好处理乱真事件，因为最常见的实现是只要接收到任何数据包都发出就绪信号，而不管文件描述符是否准备就绪。
这是水平触发的就绪通知的相对应的机制。这就要求编程中的错误检测要非常严格，否则一旦你错过了一个事件，整个连接就永远卡死了。然而，我发现边缘触发的通知机制可以使编写带OpenSSL的非阻塞客户端更简单，可以试下。
[Banga, Mogul, Drusha '99]详细描述了这种模型.
有几种APIs可以使得应用程序获得“文件描述符已就绪”的通知:
·                     kqueue()这是在FreeBSD系统上推荐使用边缘触发的方法 (and, soon, NetBSD).
FreeBSD 4.3及以后版本，NetBSD（2002.10）都支持 kqueue()/kevent()，支持边沿触发和水平触发（请查看Jonathan Lemon 的网页和他的BSDCon 2000关于kqueue的论文）。
就像/dev/poll一样，你分配一个监听对象，不过不是打开文件/dev/poll，而是调用kqueue ()来获得。需要改变你所监听的事件或者获得当前事件的列表，可以在kqueue()返回的描述符上调用kevent()来达到目的。它不仅可以监听套接字，还可以监听普通的文件的就绪，信号和I/O完成的事件也可以.
Note:在2000.10，FreeBSD的线程库和kqueue()并不能一起工作得很好，当kqueue()阻塞时，那么整个进程都将会阻塞，而不仅仅是调用kqueue()的线程。
See Poller_kqueue (cc, h, benchmarks) for an example of how to use kqueue() interchangeably with many other readiness notification schemes.
使用kqueue()的例程和库:
o                  PyKQueue -- 一个Python的kqueue()库.
o                  Ronald F.Guilmette的echo的服务器例程; 另外可以查看他在 2000.9.28在freebsd 上发表的帖子。
·                     epoll
·                     这是Linux 2.6的内核中推荐使用的边沿触发poll.
2001.7.11， Davide Libenzi提议了一个实时信号的可选方法，他称之为/dev/epoll，该方法类似与实时信号就绪通知机制，但是结合了其它更多的事件，从而在大多数的事件获取上拥有更高的效率。
epoll在将它的接口从一个/dev下的指定文件改变为系统调用sys_epoll后就合并到2.5版本的 Linux内核开发树中，另外也提供了一个为2.4老版本的内核可以使用epoll的补丁。
unifying epoll, aio, 2002 年万圣节前夕的Linux内核邮件列表就统一epoll、aio和其它的event sources 展开了很久的争论，未来可能会发生这种情况（指统一），但Davide首先还是在集中精力使epoll更稳定。
·                     Polyakov's kevent (Linux 2.6+) 的最后新闻：2006.2.9和2006.7.9，Evgeniy Polyakov发表了融合epoll和 aio的补丁，他的目标是支持网络AIO. See:
o                  the LWN article about kevent
o                  his July announcement
o                  his kevent page
o                  his naio page
o                  some recent discussion
·                     Drepper的最新网络接口 (proposal for Linux 2.6+)
·                     在2006 OLS上，Ulrich Drepper提议了一种最新的高速异步网络API. See:
o                  他的论文, "The Need for Asynchronous, Zero-Copy Network I/O"
o                  他的幻灯片
o                  LWN article from July 22
·                     实时信号（Realtime Signals）
·                     Linux2.4内核中推荐使用的边沿触发poll.
2.4的linux内核可以通过实时信号来分派套接字事件,示例如下:
/* Mask off SIGIO and the signal you want to use. */
 sigemptyset(&sigset);
sigaddset(&sigset, signum);
 sigaddset(&sigset, SIGIO);
sigprocmask(SIG_BLOCK, &m_sigset, NULL);
/* For each file descriptor, invoke F_SETOWN, F_SETSIG, and set O_ASYNC. */
fcntl(fd, F_SETOWN, (int) getpid());
fcntl(fd, F_SETSIG, signum);
flags = fcntl(fd, F_GETFL);
flags |= O_NONBLOCK|O_ASYNC;
fcntl(fd, F_SETFL, flags); 
当正常的I/O函数如read()或write()完成时，发送信号。要使用该段的话，在外层循环中编写一个普通的poll()，在循环里面，当poll()处理完所有的描述符后，进入 sigwaitinfo()循环。如果sigwaitinfo()或sigtimedwait()返回了实时信号，那么siginfo.si_fd和 siginfo_si_band给出的信息和调用poll()后pollfd.fd和pollfd.revents的几乎一样。如果你处理该I/O，那么就继续调用sigwaitinfo()。
如果sigwaitinfo()返回了传统的SIGIO，那么信号队列溢出了，你必须通过临时 改变信号处理程序为SIG_DFL来刷新信号队列，然后返回到外层的poll()循环。
See Poller_sigio (cc, h) for an example of how to use rtsignals interchangeably with many other readiness notification schemes.
See Zach Brown's phhttpd 示例代码来如何直接使用这些特点. (Or don't; phhttpd is a bit hard to figure out...)
[Provos, Lever, and Tweedie 2000] 描述了最新的phhttp的基准测试，使用了不同的sigtimewait()和sigtimedwait4()，这些调用可以使你只用一次调用便获得多个信号。有趣的是，sigtimedwait4()的主要好处是它允许应用程序测量系统负载(so it could behave appropriately)（poll()也提供了同样的系统负载测量）。
·                     Signal-per-fd
·                     Signal-per-fd是由Chandra和Mosberger提出的对实时信号的一种改进，它可以减少甚至削除实时信号的溢出通过oalescing redundant events。然而是它的性能并没有epoll好. 论文(www.hpl.hp.com/techreports/2000/HPL-2000-174.html) 比较了它和select()，/dev/poll的性能.
Vitaly Luban在2001.5.18公布了一个实现Signal-per-fd的补丁; 授权见www.luban.org/GPL/gpl.html. (到2001.9，在很重的负载情况下仍然存在稳定性问题，利用dkftpbench测试在4500个用户时将引发问题.
See Poller_sigfd (cc, h) for an example of how to use signal-per-fd interchangeably with many other readiness notification schemes.
3. 一个服务线程服务多个客户端，使用异步I/O
该方法目前还没有在Unix上普遍的使用，可能因为很少的操作系统支持异步I/O，或者因为它你需要重新修改应用程序(rethinking your applications)。在标准Unix下，异步I/O是由"aio_"接口 提供的，它把一个信号和值与每一个I/O操作关联起来。信号和其值的队列被有效地分配到用户的进程上。异步I/O是POSIX 1003.1b实时标准的扩展，也属于Single Unix Specification,version 2.
AIO使用的是边缘触发的完成时通知，例如，当一个操作完成时信号就被加入队列（也可以使用水平触发的完成时通知，通过调用aio_suspend()即可，不过我想很少人会这么做）.
glibc 2.1和后续版本提供了一个普通的实现，仅仅是为了兼容标准，而不是为了获得性能上的提高。
Ben LaHaise编写的Linux AIO实现合并到了2.5.32的内核中，它并没有采用内核线程，而是使用了一个高效的underlying api，但是目前它还不支持套接字（2.4内核也有了AIO的补丁，不过 2.5/2.6的实现有一定程序上的不同）。更多信息如下:
·                     The page "Kernel Asynchronous I/O (AIO) Support for Linux" 设法关于2.6内核中异步I/O的实现的所有的信息集中在一起。 (发表于 16 Sept 2003)
·                     Round 3: aio vs /dev/epoll by Benjamin C.R. LaHaise (presented at 2002 OLS)
·                     Asynchronous I/O Suport in Linux 2.5, by Bhattacharya, Pratt, Pulaverty, and Morgan, IBM; presented at OLS '2003
·                     Design Notes on Asynchronous I/O (aio) for Linux by Suparna Bhattacharya -- compares Ben's AIO with SGI's KAIO and a few other AIO projects
·                     Linux AIO home page - Ben's preliminary patches, mailing list, etc.
·                     linux-aio mailing list archives
·                     libaio-oracle - library implementing standard Posix AIO on top of libaio. First mentioned by Joel Becker on 18 Apr 2003.
Suparma建议先看看AIO的API.
RedHat AS和Suse SLES都在2.4的内核中提供了高性能的实现，与2.6的内核实现相似，但并不完全一样。
2006.2，在网络AIO有了一个新的尝试，具体请看Evgeniy Polyakov的基于kevent的AIO.
1999， SGI为Linux实现了一个高速的AIO，在到1.1版本时，据说可以很好的工作于磁盘I/O和网络套接字，且使用了内核线程。目前该实现依然对那些不能等待Ben的AIO套接字支持的人来说是很有用的。
O'Reilly 的"POSIX.4: Programming for the Real World"一书对aio做了很好的介绍.
这里 有一个指南介绍了早期的非标准的aio实现，可以看看，但是请记住你得把"aioread"转换为"aio_read"。
注意AIO并没有提供无阻塞的为磁盘I/O打开文件的方法，如果你在意因打开磁盘文件而引起 sleep的话，Linus建议 你在另外一个线程中调用open()而不是把希望寄托在对aio_open()系统调用上。
在Windows下，异步I/O与术语"重叠I/O"和"IOCP"(I/O Completion Port,I/O完成端口)有一定联系。Microsoft的IOCP结合了先前的如异步I/O(如aio_write)的技术，把事件完成的通知进行排队(就像使用了aio_sigevent字段的aio_write),并且它为了保持单一IOCP线程的数量从而阻止了一部分请求。（Microsoft's IOCP combines techniques from the prior art like asynchronous I/O (like aio_write) and queued completion notification (like when using the aio_sigevent field with aio_write) with a new idea of holding back some requests to try to keep the number of running threads associated with a single IOCP constant.）
更多信息请看 Mark russinovich在sysinternals.com上的文章深入解析I/O完成端口（Inside I/O Completion Ports）， Jeffrey Richter的书"Programming Server-Side Applications for Microsoft Windows 2000" (Amazon, MSPress), U.S. patent #06223207, or MSDN.
4. 一个服务线程服务一个客户端，使用阻塞I/O
... 让read()和write()阻塞. 这样不好的地方在于需要为每个客户端使用一个完整的栈，从而比较浪费内存。许多操作系统仍在处理数百个线程时存在一定的问题。如果每个线程使用2MB的栈，那么当你在32位的机器上运行 512（2^30 / 2^21=512）个线程时，你就会用光所有的1GB的用户可访问虚拟内存（Linux也是一样运行在x86上的）。你可以减小每个线程所拥有的栈内存大小，但是由于大部分线程库在一旦线程创建后就不能增大线程栈大小，所以这样做就意味着你必须使你的程序最小程度地使用内存。当然你也可以把你的程序运行在64位的处理器上去。
Linux，FreeBSD和Solaris系统的线程库一直在更新，64位的处理器也已经开始在大部分的用户中所使用。也许在不远的将来，这些喜欢使用一个线程来服务一个客户端的人也有能力服务于10000个客户了。但是在目前，如果你想支持更多的客户，你最好还是使用其它的方法。
For an unabashedly pro-thread viewpoint, see Why Events Are A Bad Idea (for High-concurrency Servers) by von Behren, Condit, and Brewer, UCB, presented at HotOS IX. Anyone from the anti-thread camp care to point out a paper that rebuts this one? :-)
LinuxThreads
LinuxTheads 是标准Linux线程库的命名。它从glibc2.0开始已经集成在glibc库中，并且高度兼容Posix标准，不过在性能和信号的支持度上稍逊一筹。
NGPT: Next Generation Posix Threads for Linux 下一代Linux Posix线程
NGPT是一个由IBM发起的项目，其目的是提供更好的Posix兼容的Linux线程支持。现在已到2.2稳定版，并且运行良好...但是NGPT team 公布 他们正在把NGPT的代码基改为support-only模式，因为他们觉得这才是支持社区长久运行的最好的方式。 NGPT小组将继续改进Linux的线程支持，但主要关注NPTL方面。 (Kudos to the NGPT team for their good work and the graceful way they conceded to NPTL.)
NPTL: Native Posix Thread Library for Linux(Linux本地Posix线程库)
NPTL是由 Ulrich Drepper ( glibc的主要维护人员)和 Ingo Molnar发起的项目，目的是提供世界级的Posix Linux线程支持。
2003.10.5，NPTL作为一个add-on目录（就像linuxthreads一样）被合并到glibc的cvs树中，所以很有可能随glibc的下一次release而一起发布。
Red Hat 9是最早的包含NPTL的发行版本（对一些用户来说有点不太方便，但是必须有人来打破这沉默[break the ice]...)
有用的NPTL 链接:
·                     NPTL讨论的邮件列表
·                     NPTL源码
·                     NPTL的最初发表
·                     最初的描述NPTL目标的白皮书
·                     修改的NPTL的最后设计的白皮书
·                     Ingo Molnar最初的基准测试表明可以处理10^6个线程
·                     Ulrich的基准测试 比较了LinuxThreads，NPTL和IBM的NGPT的各自性能，结果看来NPTL比NGPT快的多。
这是我尝试写的描述NPTL历史的文章(也可以参考Jerry Cooperstein的文章):
2002.3，NGPT小组的Bill Abt，glibc的维护者Ulrich Drepper 和其它人召开了个会议来探讨LinuxThreads的发展，会议的一个idea就是要改进mutex的性能。 Rusty Russell 等人 随后实现了 fast userspace mutexes (futexes), （如今已在NGPT和NPTL中应用了）。与会的大部分人都认为NGPT应该合并到glibc中。
然而Ulrich Drepper并不怎么喜欢NGPT，他认为他可以做得更好。 (对那些曾经想提供补丁给glibc的人来说，这应该不会令他们感到惊讶:-) 于是在接下来的几个月里，Ulrich Drepper, Ingo Molnar和其它人致力于glibc和内核的改变，然后就弄出了 Native Posix Threads Library (NPTL). NPTL使用了NGPT设计的所有内核改进（kernel enhancement），并且采用了几个最新的改进。 Ingo Molnar描述了 一下的几个内核改进：
NPTL使用了三个由NGPT引入的内核特征: getpid()返回PID，CLONE_THREAD和futexes; NPTL还使用了(并依赖)也是该项目的一部分的一个更为wider的内核特征集。
一些由NGPT引入内核的items也被修改，清除和扩展，例如线程组的处理(CLONE_THREAD). [the CLONE_THREAD changes which impacted NGPT's compatibility got synced with the NGPT folks, to make sure NGPT does not break in any unacceptable way.]
这些为NPTL开发的并且后来在NPTL中使用的内核特征都描述在设计白皮书中， http://people.redhat.com/drepper/nptl-design.pdf ...
A short list: TLS support, various clone extensions (CLONE_SETTLS, CLONE_SETTID, CLONE_CLEARTID), POSIX thread-signal handling, sys_exit() extension (release TID futex upon VM-release), the sys_exit_group() system-call, sys_execve() enhancements and support for detached threads.
There was also work put into extending the PID space - eg. procfs crashed due to 64K PID assumptions, max_pid, and pid allocation scalability work. Plus a number of performance-only improvements were done as well.
In essence the new features are a no-compromises approach to 1:1 threading - the kernel now helps in everything where it can improve threading, and we precisely do the minimally necessary set of context switches and kernel calls for every basic threading primitive.
NGPT和NPTL的一个最大的不同就是NPTL是1:1的线程模型，而NGPT是M:N的编程模型(具体请看下面). 尽管这样， Ulrich的最初的基准测试 还是表明NPTL比NGPT快很多。(NGPT小组期待查看Ulrich的测试程序来核实他的结果.)
FreeBSD线程支持
FreeBSD支持LinuxThreads和用户空间的线程库。同样，M:N的模型实现KSE在FreeBSD 5.0中引入。具体请查看www.unobvious.com/bsd/freebsd-threads.html.
2003.3.25, Jeff Roberson 发表于freebsd-arch:
... 感谢Julian, David Xu, Mini, Dan Eischen,和其它的每一位参加了KSE和libpthread开发的成员所提供的基础， Mini和我已经开发出了一个1：1模型的线程实现，它可以和KSE并行工作而不会带来任何影响。It actually helps bring M:N threading closer by testing out shared bits. ...
And 2006.7, Robert Watson提议1:1的线程模型应该为FreeBSD 7.x的默认实现:
我知道曾经讨论过这个问题，但是我认为随着7.x的向前推进，这个问题应该重新考虑。在很多普通的应用程序和特定的基准测试中，libthr明显的比libpthread在性能上要好得多。 libthr是在我们大量的平台上实现的，而libpthread却只有在几个平台上。最主要的是因为我们使得Mysql和其它的大量线程的使用者转换到"libthr"，which is suggestive, also! ... 所以strawman提议:让libthr成为7.x上的默认线程库。
NetBSD线程支持
根据Noriyuki Soda的描述:
内核支持M:N线程库是基于调度程序激活模型，合并于2003.1.18当时的NetBSD版本中。
详情请看Nathan J. Williams, Wasabi Systems, Inc.在2002年的FREENIX上的演示 An Implementation of Scheduler Activations on the NetBSD Operating System。
Solaris线程支持
Solaris的线程支持还在进一步提高evolving... 从Solaris 2到Solaris 8，默认的线程库使用的都是M:N模型, 但是Solaris 9却默认使用了1:1线程模型. 查看Sun多线程编程指南 和Sun的关于Java和Solaris线程的note.
Java在JDK 1.3.x及更早的线程支持
大家都知道，Java一直到JDK1.3.x都没有支持任何处理网络连接的方法，除了一个线程服务一个客户端的模型之外。 Volanomark是一个不错的微型测试程序，可以用来测量在某个时候不同数目的网络连接时每秒钟的信息吞吐量。在2003.5, JDK 1.3的实现实际上可以同时处理10000个连接，但是性能却严重下降了。从Table 4 可以看出JVMs可以处理10000个连接，但是随着连接数目的增长性能也逐步下降。
Note: 1:1 threading vs. M:N threading
在实现线程库的时候有一个选择就是你可以把所有的线程支持都放到内核中（也就是所谓的1：1的模型），也可以把一些线程移到用户空间上去（也就是所谓的M：N模型）。从某个角度来说, M:N被认为拥有更好的性能，但是由于很难被正确的编写，所以大部分人都远离了该方法。
·                     为什么Ingo Molnar相对于M：N更喜欢1：1
·                     Sun改为1：1的模型
·                     NGPT是Linux下的M：N线程库.
·                     Although Ulrich Drepper计划在新的glibc线程库中使用M：N的模型, 但是还是选用了1：1的模型.
·                     MacOSX 也将使用1：1的线程.
·                     FreeBSD和 NetBSD 仍然将使用M：N线程，FreeBSD 7.0也倾向于使用1：1的线程（见上面描述），可能M：N线程的拥护者最后证明它是错误的。
5. 把服务代码编译进内核
Novell和Microsoft都宣称已经在不同时期完成了该工作，至少NFS的实现完成了该工作。 khttpd在Linux下为静态web页面完成了该工作， Ingo Molnar完成了"TUX" (Threaded linUX webserver) ，这是一个Linux下的快速的可扩展的内核空间的HTTP服务器。 Ingo在2000.9.1宣布 alpha版本的TUX可以在 ftp://ftp.redhat.com/pub/redhat/tux下载, 并且介绍了如何加入其邮件列表来获取更多信息。
在Linux内核的邮件列表上讨论了该方法的好处和缺点，多数人认为不应该把web服务器放进内核中，相反内核加入最小的钩子hooks来提高web服务器的性能，这样对其它形式的服务器就有益。具体请看 Zach Brown的讨论 对比用户级别和内核的http服务器。在2.4的linux内核中为用户程序提供了足够的权力（power），就像X15 服务器运行的速度和TUX几乎一样，但是它没有对内核做任何改变。
注释
Richard Gooch曾经写了一篇讨论I/O选项的论文。
在2001, Tim Brecht和MMichal Ostrowski为使用简单的基于select的服务器 做了各种策略的测试。 测试的数据值得看一看。
在2003, Tim Brecht发表了 userver的源码, 该web服务器是整合了Abhishek Chandra, David Mosberger, David Pariag和Michal Ostrowski所写的几个服务器，可以使用select(), poll(), epoll()和sigio.
早在1999.3, Dean Gaudet就表示:
我一直在问“为什么你们不使用基于select/event像Zeus的模型，它明显是最快的。”...
他们不使用它的原因可以简单归结为“太难理解了，并且其中的性能指标还不清楚”，但是几个月后，当该模型变得易懂时人们就开始愿意使用它了。
Mark Russinovich写了 一篇评论和 文章讨论了在的linux 2.2内核上的I/O策略问题。尽管某些地方似乎有点错误，不过还是值得去看。特别是他认为Linux2.2的异步I/O (请看上面的F_SETSIG) 并没有在数据准备好时通知用户进程，而只有在新的连接到达时才有。这看起来是一个奇怪的误解。还可以看看 早期的一些comments, Ingo Molnar在1999.4.30所举的反例, Russinovich在1999.5.2的comments, Alan Cox的 反例，和各种 linux内核邮件. 我怀疑他想说的是Linux不支持异步磁盘I/O，这在过去是正确的，但是现在SGI已经实现了KAIO，它已不再正确了。
查看页面 sysinternals.com和 MSDN了解一下“完成端口”，据说它是NT中独特的技术，简单说，win32的"重叠I/O"被认为是太低水平而不方面使用，“完成端口”是提供了完成事件队列的封装，再加上魔法般的调度，通过允许更多的线程来获得完成事件如果该端口上的其它已获得完成事件的线程处于睡眠中时（可能正在处理阻塞I/O），从而可以保持运行线程数目恒定（scheduling magic that tries to keep the number of running threads constant by allowing more threads to pick up completion events if other threads that had picked up completion events from this port are sleeping (perhaps doing blocking I/O).
查看OS/400的I/O完成端口支持.
在1999.9，在linux内核邮件列表上曾有一次非常有趣的讨论，讨论题目为 "15,000 个并发连接" (并且延续到第二周). Highlights:
·                     Ed Hall 发表了一些他自己的经验：他已经在运行Solaris的UP P2/333上完成>1000个连接每秒。他的代码使用了一个很小的线程池（每个cpu 1或者2个线程池），每个线程池使用事件模型来管理大量的客户端连接。
·                     Mike Jagdis 发表了一份关于poll/select开销的分析, 他表示“目前的select/poll实现还可以进行大幅度的性能提升，特别是在阻塞的环境下，但是随着文件描述符的增多epoll/select的开销也会同步增长，因为epoll/select没有，也不能够记住它感兴趣的描述符。但这很容易通过一个新的API来修正。随时欢迎任何建议…”
·                     Mike 发表了他 为提高select()和poll()的性能所做的工作.
·                     Mike posted a bit about a possible API to replace poll()/select(): "How about a 'device like' API where you write 'pollfd like' structs, the 'device' listens for events and delivers 'pollfd like' structs representing them when you read it? ... "
·                     Rogier Wolff suggested using "the API that the digital guys suggested", http://www.cs.rice.edu/~gaurav/papers/usenix99.ps
·                     Joerg Pommnitz pointed out that any new API along these lines should be able to wait for not just file descriptor events, but also signals and maybe SYSV-IPC. Our synchronization primitives should certainly be able to do what Win32's WaitForMultipleObjects can, at least.
·                     Stephen Tweedie asserted that the combination of F_SETSIG, queued realtime signals, and sigwaitinfo() was a superset of the API proposed in http://www.cs.rice.edu/~gaurav/papers/usenix99.ps. He also mentions that you keep the signal blocked at all times if you're interested in performance; instead of the signal being delivered asynchronously, the process grabs the next one from the queue with sigwaitinfo().
·                     Jayson Nordwick把F_SETSIG同步事件模型和完成端口进行了分析比较，总结出二者非常相似。
·                     Alan Cox 表示 that an older rev of SCT's SIGIO patch is included in 2.3.18ac.
·                     Jordan Mendelson 发表了 一些示例代码来展示如何使用F_SETSIG.
·                     Stephen C. Tweedie continued the comparison of completion ports and F_SETSIG, and noted: "With a signal dequeuing mechanism, your application is going to get signals destined for various library components if libraries are using the same mechanism," but the library can set up its own signal handler, so this shouldn't affect the program (much).
·                     Doug Royer 表示他在Solaris2.6上实现了10万个连接。他工作在Sun calendar server上。noted that he'd gotten 100,000 connections on Solaris 2.6 while he was working on the Sun calendar server. Others chimed in with estimates of how much RAM that would require on Linux, and what bottlenecks would be hit.
Interesting reading!
 
在打开文件句柄数目上的限制
·                     任何一种Unix: 限制可以通过ulimit或setrlimit来设定.
·                     Solaris: 见 the Solaris FAQ, question 3.46 (or thereabouts; 他们会周期性的对问题重新编号).
·                     FreeBSD:
·                      
·                     编辑文件 /boot/loader.conf, 增加一行：
set kern.maxfiles=XXXX
其中XXXX是系统想要达到关于文件描述符上的极限。重启系统生效. 感谢一位不知名的读者，他在信中声称，他在FreeBSD 4.3上做到了远超过10000个接连数，他说，
"FWIW: 实际你不能只是简单的通过sysctl调整FreeBSD的最大连接数，.... 你得通过修改/boot/loader.conf才可以.
The reason for 原因是初始化sockets和 tcpcb 结构体的zalloci()调用早在系统启动期就发生。
this is that the zalloci() calls for initializing the sockets and tcpcb structures zones occurs very early in system startup, in order that the zone be both type stable and that it be swappable.
You will also need to set the number of mbufs much higher, since you will (on an unmodified kernel) chew up one mbuf per connection for tcptempl structures, which are used to implement keepalive."
另一位读者称：
"至于在 FreeBSD 4.4, 结构体 tcptempl 将不再保留;你不必再担心一个mbuf被破坏了。 you no longer have to worry about one mbuf being chewed up per connection."
其它参见:
o                  the FreeBSD 手册
o                  SYSCTL TUNING, LOADER TUNABLES, and KERNEL CONFIG TUNING in 'man tuning'
o                  The Effects of Tuning a FreeBSD 4.3 Box for High Performance, Daemon News, Aug 2001
o                  postfix.org tuning notes, covering FreeBSD 4.2 and 4.4
o                  the Measurement Factory's notes, circa FreeBSD 4.3
·                     OpenBSD: 一位读者称：
"In OpenBSD, an additional tweak is required to increase the number of open filehandles available per process: the openfiles-cur parameter in /etc/login.conf needs to be increased. You can change kern.maxfiles either with sysctl -w or in sysctl.conf but it has no effect. This matters because as shipped, the login.conf limits are a quite low 64 for nonprivileged processes, 128 for privileged."
·                     Linux: 参见 Bodo Bauer's /proc 文档. 在 2.4 kernels内核上:
通过命令：echo 32768 > /proc/sys/fs/file-max 
增加了系统限制的可打开文件描述符的数目。另外，命令
ulimit -n 32768
增加了当前进程的可打开文件描述符的数目。
在 2.2.x 内核上, 通过命令
echo 32768 > /proc/sys/fs/file-max echo 65536 > /proc/sys/fs/inode-max
增加了系统限制的可打开文件描述符的数目。, 使用命令：
ulimit -n 32768
增加了当前进程的可打开文件描述符的数目为32768。
我查证过，通过上面这种方式，在Red Hat 6.0上一个进程可打开至少31000个文件描述符。另一个伙伴通过同样的方式验证了，在2.2.12核心上，至少可以打开9万个文件描述符。上限看起来取决于可用内存。
Stephen C. Tweedie 发表了 about how to set ulimit limits globally or per-user at boot time using initscript and pam_limit.
在较老的 2.2 内核上, 尽管可以使用上述命令去修改相关的内核参数，但每个进程中可打开的文件数目依然限制在1024个.
也可查看Oskar's 1998 post, 其中谈到了在2.0.36内核中，在文件描述符的问题上，每进程和系统范围内对此的限制。
线程上的限制
在任何构架上，你可能需要减少分配给每一个线程的堆栈空间以避免耗尽虚拟地址空间。如果你使用pthreads库，你可以用pthread_attr_init() 在运行期设定线程堆栈大小。
·                     Solaris: 有多少内存就支持多少线程。仅道听途说。
·                     带有NPTL[译注1]的Linux 2.6 内核: /proc/sys/vm/max_map_count 如果需要的话，可以增加到大约32000个线程。(如果你要使用这么多的线程，你需要使线程的堆栈小一点。或者，除非你用64位的处理器。) 更多信息请参见NPTL 邮件列表, 比如，有关线程的主题 "不能再创建更多的32K线程了吗？
[译注1：在GNU/Linux操作系统中，Native POSIX Thread Library (NPTL)是一种软件特性，它能够使遵循POSIX Threads规范的程序在Linux内核上高效的运行。]
·                     Linux 2.4: /proc/sys/kernel/threads-max 指出了系统的最大线程数目。在我的Red Hat 8操作系统上缺省是 2047 个. 最常见的方式，你可以增加这个值通过echo把这个新值传到文件，比如： "echo 4000 > /proc/sys/kernel/threads-max"
·                     Linux 2.2: 甚至2.2.13版本的内核也限制了线程的数量。至少Intel是如此. 我不知道其它CPU架构上的限制。 Mingo为Intel平台上的2.1.131版本发布的补丁（ patch for 2.1.131 on Intel）去除了这个限制. 好像集成到2.3.20版本中了.
其它的参看 Volano's detailed instructions for raising file, thread, and FD_SET limits in the 2.2 kernel. 哦，这个重要的文档帮你搞定了很多你自己难以搞定的事情。但就是有点过时了。
·                     Java: 参见Volano详细的基准测试报告（Volano's detailed benchmark info）, 还有他们的 info on how to tune various systems to handle lots of threads.
Java 的议题
Up through JDK 1.3, Java's standard networking libraries mostly offered the one-thread-per-client model. There was a way to do nonblocking reads, but no way to do nonblocking writes.
In May 2001, JDK 1.4 introduced the package java.nio to provide full support for nonblocking I/O (and some other goodies). See the release notes for some caveats. Try it out and give Sun feedback!
HP's java also includes a Thread Polling API.
In 2000, Matt Welsh implemented nonblocking sockets for Java; his performance benchmarks show that they have advantages over blocking sockets in servers handling many (up to 10000) connections. His class library is called java-nbio; it's part of the Sandstorm project. Benchmarks showing performance with 10000 connections are available.
See also Dean Gaudet's essay on the subject of Java, network I/O, and threads, and the paper by Matt Welsh on events vs. worker threads.
Before NIO, there were several proposals for improving Java's networking APIs:
·                     Matt Welsh's Jaguar system proposes preserialized objects, new Java bytecodes, and memory management changes to allow the use of asynchronous I/O with Java.
·                     Interfacing Java to the Virtual Interface Architecture, by C-C. Chang and T. von Eicken, proposes memory management changes to allow the use of asynchronous I/O with Java.
·                     JSR-51 was the Sun project that came up with the java.nio package. Matt Welsh participated (who says Sun doesn't listen?).
其它的提示
·                     零拷贝技术（Zero-Copy）[译注2]
·                     正常的情况下，数据从此处到彼处需要被拷贝很多次。任何旨在消除这些拷贝使之减少到物理最小量拷贝的技术被称之为“零拷贝技术”。
 [译注2：零拷贝技术分为两步：
1、硬件到内核，实现的前提是网卡必须支持DMA，对于不支持DMA的网卡无法实现零拷贝。
2、内核到用户层，将系统内核中存储数据报的内存区域映射到检测程序的应用程序空间或者在用户空间建立一缓存，并将其映射到内核空间。
]
 
o                  在 Linux内核 2.4.17-2.4.20下，Thomas Ogrisegg's zero-copy send patch 为内存映射文件所打的补丁，声称快过sendfile().
o                  IO-Lite是关于一组I/O原语的方案，它省去了许多不必要的拷贝。
o                  早在1999年Alan Cox提出零拷贝（zero-copy）有时不值得如此麻烦(虽然他也很喜欢sendfile().)
o                  在2000年7月的时候，Ingo 在2.4内核上为TUX实现了一种TCP 的零拷贝（implemented a form of zero-copy TCP）, 并且他声称他接着会在用户空间上实现了这一功能。.
o                  Drew Gallatin 和 Robert Picco 增加了一些零拷贝的特性到FreeBSD; 如果你在一个套接字上调用write() 或者 read()，指针是按页对齐的，发送的数据的总量至少为一页，传输的数据量至少是一页，（page-aligned）the idea seems to be that if you call write() or read() on a socket, the pointer is page-aligned, and the amount of data transferred is at least a page, *and* you don't immediately reuse the buffer, memory management tricks will be used to avoid copies. But see followups to this message on linux-kernel for people's misgivings about the speed of those memory management tricks.
根据 Noriyuki Soda的说法:
发送方的零拷贝技术自从NetBSD-1.6发行版本就得到了支持。你需要设定内核参数“SOSEND_LOAN”。这个参数是目前所有NetBSD的缺省参数。（你可以在内核选项中通过设定"SOSEND_NO_LOAN"取消这个特性）。在这个特性的支持下，当超过4K的数据被发送时，零拷贝技术自动生效。
 
o                  The sendfile() system call can implement zero-copy networking.
o                  sendfile()系统调用能够实现网络应用中的零拷贝。在Linux和FreeBSD中 sendfile()函数允许你告诉内核发送一个文件的部分或全部。内核会尽可能有效的完成操作。这个调用在使用多线程的服务器上或使用非阻塞IO的服务器上也同样工作得很好。(在Linux平台上, 目前文档并不完善; use _syscall4 to call it. Andi Kleen 正在写一个新的使用文档来包含这个主题。参见Jeff Tranter 的Exploring The sendfile System Call in Linux Gazette issue 91.) Rumor has it, ftp.cdrom.com 从 sendfile()中显著的受益。
在linux2.4 内核上正在实现一个sendfile()的零拷贝方案。参见LWN Jan 25 2001.
一个开发者使用了Freebsd下的sendfile()，他反馈说，使用POLLWRBAND而不是POLLOUT造成很大的（性能）差异。
Solaris 8 (as of the July 2001 update)下有一个新的系统调用'sendfilev'。一个使用文档在这里……copy of the man page is here.8 07年1月的发布要点（release notes）也提到了它。我猜想这个调用在阻塞模式下发送（数据）到一个套接字最为有用。使用非阻塞套接字会有点麻烦。. Solaris
Solaris 8 (as of the July 2001 update) has a new system call 'sendfilev'. A copy of the man page is here.. The Solaris 8 7/01 release notes also mention it. I suspect that this will be most useful when sending to a socket in blocking mode; it'd be a bit of a pain to use with a nonblocking socket.
使用writev（或TCP_CORK ）来避免小帧  Avoid small frames by using writev (or TCP_CORK)
TCP_CORK是一个在linux下的套接字的新的选项，它告诉内核避免发送个别的帧，当有很多小的write()调用，而因为某些原因你又不能将它们捆绑在一起，在这种情况下TCP_CORK会非常有作用。不设定这个选项，而是刷新缓存。更好点是使用writev()。。。。。。
 
参见 LWN Jan 25 2001 摘要信息，关于linux内核中的TCP_CORK,还有另个一个可能的选择MSG_MORE,里面其中有一些有趣的讨论.
Behave sensibly on overload.在超负荷状态下智能感知
[Provos, Lever, and Tweedie 2000] notes that dropping incoming connections when the server is overloaded improved the shape of the performance curve, and reduced the overall error rate. They used a smoothed version of "number of clients with I/O ready" as a measure of overload. This technique should be easily applicable to servers written with select, poll, or any system call that returns a count of readiness events per call (e.g. /dev/poll or sigtimedwait4()).
Some programs can benefit from using non-Posix threads. 使用非Posix线程令一些程序受益
Not all threads are created equal. The clone() function in Linux (and its friends in other operating systems) lets you create a thread that has its own current working directory, for instance, which can be very helpful when implementing an ftp server. See Hoser FTPd for an example of the use of native threads rather than pthreads.
Caching your own data can sometimes be a win.缓存你自己的数据有时好处很大
"Re: fix for hybrid server problems" by Vivek Sadananda Pai (vivek@cs.rice.edu) on new-httpd, May 9th, states:
"I've compared the raw performance of a select-based server with a multiple-process server on both FreeBSD and Solaris/x86. On microbenchmarks, there's only a marginal difference in performance stemming from the software architecture. The big performance win for select-based servers stems from doing application-level caching. While multiple-process servers can do it at a higher cost, it's harder to get the same benefits on real workloads (vs microbenchmarks). I'll be presenting those measurements as part of a paper that'll appear at the next Usenix conference. If you've got postscript, the paper is available at http://www.cs.rice.edu/~vivek/flash99/"
 
Other limits其它限制
老的系统库使用16位的变量来保存文件句柄，当有超过32767个句柄时，这就会引起麻烦。glibc2.1应该没有这个问题.
许多系统使用16位变量来保存进程或线程ID。It would be interesting to port the Volano scalability benchmark to C, and see what the upper limit on number of threads is for the various operating systems.
太多的线程局部内存被某些操作系统事件分配好，如果每个线程分配1MB，而总共的虚拟内存空间才2GB，这会造成只能生成2000个线程的上限。
参看这个页面最后的性能比较图。http://www.acme.com/software/thttpd/benchmarks.html. Notice how various servers have trouble above 128 connections, even on Solaris 2.6? 如果有人想出为什么，请告诉我。
注意 :如果TCP栈存在一个bug，而引起在SYN或FIN时间上的小小的延时（200ms）,这在Linux 2.2.0-2.2.6  中存在的，操作系统或http后台程序在打开的连接数上有一个硬性限制，if the TCP stack has a bug that causes a short (200ms) delay at SYN or FIN time, as Linux 2.2.0-2.2.6 had, and the OS or http daemon has a hard limit on the number of connections open, you would expect exactly this behavior. There may be other causes.
核心问题
对Linux来说，核心的瓶颈正不断的被突破。可以查看Linux Weekly News, Kernel Traffic, the Linux-Kernel mailing list, 和 my Mindcraft Redux page.
1999年3月，微软主办了一次基准测试来比较NT和Linux，比较他们在可服务的http和smb客户的最大数量上面的性能。结果显示 Linux性能不佳。更多的信息可以参考我的文章：my article on Mindcraft's April 1999 Benchmarks 。
See also The Linux Scalability Project. They're doing interesting work, including Niels Provos' hinting poll patch, and some work on the thundering herd problem.
See also Mike Jagdis' work on improving select() and poll(); here's Mike's post about it.
Mohit Aron (aron@cs.rice.edu) writes that rate-based clocking in TCP can improve HTTP response time over 'slow' connections by 80%.
 
测试服务器性能
两种测试很简单、也有趣但同时也很难。
每秒钟原始连接数。raw connections per second (你可以在一秒钟内处理多少个512字节的文件呢？)
total transfer rate on large files with many slow clients (how many 28.8k modem clients can simultaneously download from your server before performance goes to pot?)
Jef Poskanzer发表了许多关于比较web服务器性能的基准测试。. 参看http://www.acme.com/software/thttpd/benchmarks.html for his results.
I also have a few old notes about comparing thttpd to Apache that may be of interest to beginners.
Chuck Lever keeps reminding us about Banga and Druschel's paper on web server benchmarking. It's worth a read.
IBM has an excellent paper titled Java server benchmarks [Baylor et al, 2000]. It's worth a read.
Examples
值得关注的基于select()的服务器
thttpd 非常简单. 它使用单进程，也有很好的性能表现，但性能不能随着CPU的数目扩展。也可以使用kqueue.
mathopd. 类似于thttpd.
fhttpd
boa
Roxen
Zeus, 一个商业的服务器，试图做到的绝对的快。参见他们的tuning guide.
其它的非Java 服务器列表在http://www.acme.com/software/thttpd/benchmarks.html
BetaFTPd
Flash-Lite – 使用IO-Lite的web服务器.
Flash:一个高效的和可移植的Web服务器 – 使用select(), mmap(), mincore()
The Flash web server as of 2003 -- uses select(), modified sendfile(), async open()
xitami – 没有使用线程。为了系统的可移植性，使用 select()来实现自己的线程抽象。
Medusa - a server-writing toolkit in Python that tries to deliver very high performance.
userver – 一个小型的http服务器可以使用select, poll, epoll, 或者 sigio
值得关注的基于 /dev/poll的服务器
N. Provos, C. Lever, "Scalable Network I/O in Linux," May, 2000. [FREENIX track, Proc. USENIX 2000, San Diego, California (June, 2000).] Describes a version of thttpd modified to support /dev/poll. Performance is compared with phhttpd.
值得关注的基于kqueue()的服务器
thttpd (as of version 2.21?)
Adrian Chadd says "I'm doing a lot of work to make squid actually LIKE a kqueue IO system"; it's an official Squid subproject; see http://squid.sourceforge.net/projects.html#commloops. (This is apparently newer than Benno's patch.)
值得关注的基于实时信号的服务器
Chromium's X15. This uses the 2.4 kernel's SIGIO feature together with sendfile() and TCP_CORK, and reportedly achieves higher speed than even TUX. The source is available under a community source (not open source) license. See the original announcement by Fabio Riccardi.
Zach Brown's phhttpd - "a quick web server that was written to showcase the sigio/siginfo event model. consider this code highly experimental and yourself highly mental if you try and use it in a production environment." Uses the siginfo features of 2.3.21 or later, and includes the needed patches for earlier kernels. Rumored to be even faster than khttpd. See his post of 31 May 1999 for some notes.
值得关注的基于线程的服务器
Hoser FTPD. See their benchmark page.
Peter Eriksson's phttpd and
pftpd
The Java-based servers listed at http://www.acme.com/software/thttpd/benchmarks.html
Sun's Java Web Server (which has been reported to handle 500 simultaneous clients)
值得关注的基于内核中的服务器
khttpd
"TUX" (Threaded linUX webserver) by Ingo Molnar et al. For 2.4 kernel.
其它值得关注的链接
Jeff Darcy's notes on high-performance server design
Ericsson's ARIES project -- benchmark results for Apache 1 vs. Apache 2 vs. Tomcat on 1 to 12 processors
Prof. Peter Ladkin's Web Server Performance page.
Novell's FastCache -- claims 10000 hits per second. Quite the pretty performance graph.
Rik van Riel's Linux Performance Tuning site
修改日志
$Log: c10k.html,v $
Revision 1.212 2006/09/02 14:52:13 dank
added asio
 
Revision 1.211 2006/07/27 10:28:58 dank
Link to Cal Henderson's book.
 
Revision 1.210 2006/07/27 10:18:58 dank
Listify polyakov links, add Drepper's new proposal, note that FreeBSD 7 might move to 1:1
 
Revision 1.209 2006/07/13 15:07:03 dank
link to Scale! library, updated Polyakov links
 
Revision 1.208 2006/07/13 14:50:29 dank
Link to Polyakov's patches
 
Revision 1.207 2003/11/03 08:09:39 dank
Link to Linus's message deprecating the idea of aio_open
 
Revision 1.206 2003/11/03 07:44:34 dank
link to userver
 
Revision 1.205 2003/11/03 06:55:26 dank
Link to Vivek Pei's new Flash paper, mention great specweb99 score
